{

/////////////// STARTING TEMPLATES ///////////////
  "normal starter": {
    "prefix": "NSTART",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "int main()",
      "{",
      "    ",
      "}"
    ],
    "description": "normal starter"
  },
  "Template for competitive programming": {
    "prefix": "cp",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#define ll long long",
      "#define ld long double",
      "#define ar array",
      "",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "using namespace __gnu_pbds;",
      "",
      "template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
      "",
      "#define vt                 vector",
      "#define pb                 push_back",
      "#define all(c)             (c).begin(), (c).end()",
      "#define sz(x)              (int)(x).size()",
      "#define all0(a)            memset(a,0,sizeof(a))",
      "#define all1(a)            memset(a,-1,sizeof(a))",
      "#define lc(x)              x<<1",
      "#define rc(x)              x<<1|1",
      "#define tm                 (tl+tr)/2",
      "#define dec(a)             fixed<<setprecision(a)",
      "#define min3(a,b,c)        min(a,min(b,c))",
      "#define max3(a,b,c)        max(a,max(b,c))",
      "#define bpc(a)             __builtin_popcountll(a)",
      "#define UNIQUE(x)          sort(all(x)), x.resize(unique(all(x))-x.begin())",
      "#define stoi               stoll",
      "",
      "// BIT",
      "int topbit(ll t) { return t == 0 ? -1 : 63 - __builtin_clzll(t); }",
      "int lowbit(ll a) { return a == 0 ? 64 : __builtin_ctzll(a); }",
      "ll  allbit(int n) { return (1LL << n) - 1; }",
      "bool ispow2(int i) { return i && (i & -i) == i; }",
      "",
      "const ld PI = acos((ld)-1);",
      "typedef pair<int, int> pi;",
      "typedef pair<ll, ll> pl;",
      "typedef pair<ld, ld> pld;",
      "",
      "#define F_OR(i, a, b, s) for (int i=(a); (s)>0?i<(b):i>(b); i+=(s))",
      "#define F_OR1(e) F_OR(i, 0, e, 1)",
      "#define F_OR2(i, e) F_OR(i, 0, e, 1)",
      "#define F_OR3(i, b, e) F_OR(i, b, e, 1)",
      "#define F_OR4(i, b, e, s) F_OR(i, b, e, s)",
      "#define GET5(a, b, c, d, e, ...) e",
      "#define F_ORC(...) GET5(__VA_ARGS__, F_OR4, F_OR3, F_OR2, F_OR1)",
      "#define FOR(...) F_ORC(__VA_ARGS__)(__VA_ARGS__)",
      "#define EACH(x, a) for (auto& x: a)",
      "",
      "template<class T> bool umin(T& a, const T& b) {",
      "    return b<a?a=b, 1:0;",
      "}",
      "template<class T> bool umax(T& a, const T& b) { ",
      "    return a<b?a=b, 1:0;",
      "} ",
      "ll min(ll a, ll b) {",
      "    if(a < b) return a;",
      "    return b;",
      "}",
      "ll max(ll a, ll b) {",
      "    if(a > b) return a;",
        "    return b;",
        "}",
  
      "template<typename T>",
      "T max(vector<T> &v, int from = 0, int to = -1)",
      "{",
      "    if(to == -1)",
      "        to = sz(v);",
      "    return *max_element(v.begin()+from, v.begin()+to);",
      "}",
      "template<typename T>",
      "T min(vector<T> &v, int from = 0, int to = -1)",
      "{",
      "    if(to == -1)",
      "        to = sz(v);",
      "    return *min_element(v.begin()+from, v.begin()+to);",
      "}",
      "template<typename T>",
      "ll sum(vector<T> &v, int from = 0, int to = -1)",
      "{",
      "    if(to == -1)",
      "        to = sz(v);",
      "    ll sum = 0;",
      "    for(int i=from;i<to;i++)",
      "        sum += v[i];",
      "    return sum;",
      "}",
      "template<typename T>",
      "int minarg(vector<T> &v, int from = 0, int to = -1)",
      "{",
      "    if(to == -1)",
      "        to = sz(v);",
      "    return min_element(v.begin()+from, v.begin()+to)-v.begin();",
      "}",
      "template<typename T>",
      "int maxarg(vector<T> &v, int from = 0, int to = -1)",
      "{",
      "    if(to == -1)",
      "        to = sz(v);",
      "    return max_element(v.begin()+from, v.begin()+to)-v.begin();",
      "}",
      "",
      "template <class T> T ceil(T x, T y) {",
      "    if(y < 0) x = -x, y = -y;",
      "    assert(y >= 1);",
      "    return (x > 0 ? (x + y - 1) / y : x / y);",
      "}",
      "template <class T> T floor(T x, T y) {",
      "    if(y < 0) x = -x, y = -y;",
      "    assert(y >= 1);",
      "    return (x > 0 ? x / y : (x + y - 1) / y);",
      "}",
      "",
      "ll FIRSTTRUE(function<bool(ll)> f, ll lb, ll rb) {",
      "    while(lb<rb) {",
      "        ll mb=(lb+rb)/2;",
      "        f(mb)?rb=mb:lb=mb+1; ",
      "    } ",
      "    return lb;",
      "}",
      "ll LASTTRUE(function<bool(ll)> f, ll lb, ll rb) {",
      "    while(lb<rb) {",
      "        ll mb=(lb+rb+1)/2;",
      "        f(mb)?lb=mb:rb=mb-1; ",
      "    } ",
      "    return lb;",
      "}",
      "",
      "template<class A> void read(vt<A>& v);",
      "template<class A, size_t S> void read(ar<A, S>& a);",
      "template<class T> void read(T& x) {",
      "    cin >> x;",
      "}",
      "void read(double& d) {",
      "    string t;",
      "    read(t);",
      "    d=stod(t);",
      "}",
      "void read(long double& d) {",
      "    string t;",
      "    read(t);",
      "    d=stold(t);",
      "}",
      "template<class H, class... T> void read(H& h, T&... t) {",
      "    read(h);",
      "    read(t...);",
      "}",
      "template<class A, class B> void read(pair<A, B>& P) {",
      "    read(P.first, P.second);",
      "}",
      "template<class A> void read(vt<A>& x) {",
      "    EACH(a, x)",
      "        read(a);",
      "}",
      "template<class A, size_t S> void read(array<A, S>& x) {",
      "    EACH(a, x)",
      "        read(a);",
      "}",
      "",
      "template<class A, class B>",
      "string to_string(pair<A, B> P) {",
      "    return to_string(P.first) + \" \" + to_string(P.second);",
      "}",
      "",
      "string to_string(char c) {",
      "    return string(1, c);",
      "}",
      "string to_string(bool b) {",
      "    return b?\"true\":\"false\";",
      "}",
      "string to_string(const char* s) {",
      "    return string(s);",
      "}",
      "string to_string(string s) {",
      "    return s;",
      "}",
      "string to_string(vt<bool> v) {",
      "    string res;",
      "    FOR(sz(v))",
      "        res+=char('0'+v[i]);",
      "    return res;",
      "}",
      "",
      "template<size_t S> string to_string(bitset<S> b) {",
      "    string res;",
      "    FOR(S)",
      "        res+=char('0'+b[i]);",
      "    return res;",
      "}",
      "template<class T> string to_string(T v) {",
      "    bool f=1;",
      "    string res;",
      "    EACH(x, v) {",
      "        if(!f)",
      "            res+=' ';",
      "        f=0;",
      "        res+=to_string(x);",
      "    }",
      "    return res;",
      "}",
      "",
      "template<class A> void write(A x) {",
      "    cout << to_string(x);",
      "}",
      "template<class H, class... T> void write(const H& h, const T&... t) { ",
      "    write(h);",
      "    write(t...);",
      "}",
      "void print() {",
      "    write(\"\\n\");",
      "}",
      "template<class H, class... T> void print(const H& h, const T&... t) { ",
      "    write(h);",
      "    if(sizeof...(t))",
      "        write(' ');",
      "    print(t...);",
      "}",
      "template<typename T>",
      "void print(vector<vector<T>> &v) {",
      "    EACH(i, v)",
      "        print(i);",
      "}",
      "",
      "void DBG() {",
      "    cerr << \"]\" << endl;",
      "}",
      "template<class H, class... T> void DBG(H h, T... t) {",
      "    cerr << to_string(h);",
      "    if(sizeof...(t))",
      "        cerr << \", \";",
      "    DBG(t...);",
      "}",
      "// #define _DEBUG",
      "#ifdef _DEBUG",
      "#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)",
      "#else",
      "#define dbg(...) 0",
      "#endif",
      "",
      "",
      "template<class T> void offset(ll o, T& x) {",
      "    x+=o;",
      "}",
      "template<class T> void offset(ll o, vt<T>& x) {",
      "    EACH(a, x)",
      "        offset(o, a);",
      "}",
      "template<class T, size_t S> void offset(ll o, ar<T, S>& x) {",
      "    EACH(a, x)",
      "        offset(o, a);",
      "}",
      "",
      "mt19937 mt_rng(chrono::steady_clock::now().time_since_epoch().count());",
      "ll randint(ll a, ll b) {",
      "    return uniform_int_distribution<ll>(a, b)(mt_rng);",
      "}",
      "",
      "template<class T, class U> void vti(vt<T> &v, U x, size_t n) {",
      "    v=vt<T>(n, x);",
      "}",
      "template<class T, class U> void vti(vt<T> &v, U x, size_t n, size_t m...) {",
      "    v=vt<T>(n);",
      "    EACH(a, v)",
      "        vti(a, x, m);",
      "}",
      "",
      "const int d4i[4]={-1, 0, 1, 0}, d4j[4]={0, 1, 0, -1};",
      "const int d8i[8]={-1, -1, 0, 1, 1, 1, 0, -1}, d8j[8]={0, 1, 1, 1, 0, -1, -1, -1};",
      "",
      "ll hell = 1e9+7; // 998244353;",
      "",
      "inline ll mod(ll x,ll p = hell) {return (x < 0?(x%p)+p:x%p);}",
      "",
      "ll power(ll b,ll e,ll m)",
      "{",
      "    if(e==0) return 1;",
      "    if(e&1) return b*power(b*b%m,e/2,m)%m;",
      "    return power(b*b%m,e/2,m);",
      "}",
      "ll power( ll b, ll e)",
      "{",
      "    if(e==0) return 1;",
      "    if(e&1) return b*power(b*b,e/2);",
      "    return power(b*b,e/2);",
      "}",
      "inline ll mod_inverse(ll x, ll m=hell)",
      "{",
      "    return power(x, m-2, m);",
      "}",
      "",
      "",
      "",
      "#define endl '\\n'",
      "const int MX = 2e5+5;",
      "const ll INF = 1e18;",
      "",
      "",
      "#define x_cord  first",
      "#define y_cord  second",
      "",
      "",
      "",
      "",
      "void solve() {",
      "    ",
      "    ${2}",
      "    ",
      "    ",
      "}",
      "",
      "",
      "",
      "",
      "void preprocess()",
      "{",
      "    #ifdef ALL_DIVISORS",
      "        alldivisors();",
      "    #endif",
      "    #ifdef LINEAR_SIEVE",
      "        linear_sieve();",
      "    #endif",
      "    #ifdef TOTIENT_SIEVE",
      "        totient_sieve();",
      "    #endif",
      "    #ifdef MOBIUS",
      "        calc_mobius();",
      "    #endif",
      "    #ifdef ALL_FACTORIAL",
      "        factcalc();",
      "    #endif",
      "    #ifdef INVERSEFACT",
      "        inv_factcalc();",
      "    #endif",
      "}",
      "",
      "signed main() {",
      "    ios::sync_with_stdio(0);",
      "    cin.tie(0);",
      "    // freopen(\"input.txt\",\"r\",stdin);",
      "    // freopen(\"output.txt\",\"w\",stdout);",
      "    preprocess();",
      "    int t=1;",
      "    ${1}// read(t);",
      "    FOR(t) {",
      "        // write(\"Case #\", i+1, \": \");",
      "        solve();",
      "    }",
      "}"
    ],
    "description": "Template for competitive programming"
  },


//////////////// GEOMETRY /////////////////////////
  "Convex Hull Graham Scan": {
    "prefix": "convex hull",
    "body": [
      "",
      "#define T pi",
      "",
      "bool cmp(T a, T b) {",
      "    return a.x_cord < b.x_cord || (a.x_cord == b.x_cord && a.y_cord < b.y_cord);",
      "}",
      "",
      "bool cw(T a, T b, T c) {",
      "    return a.x_cord*(b.y_cord-c.y_cord)+b.x_cord*(c.y_cord-a.y_cord)+c.x_cord*(a.y_cord-b.y_cord) < 0;",
      "}",
      "",
      "bool ccw(T a, T b, T c) {",
      "    return a.x_cord*(b.y_cord-c.y_cord)+b.x_cord*(c.y_cord-a.y_cord)+c.x_cord*(a.y_cord-b.y_cord) > 0;",
      "}",
      "",
      "void convex_hull(vector<T>& a) {",
      "    int tot = sz(a);",
      "",
      "    if (a.size() == 1)",
      "        return;",
      "",
      "    sort(a.begin(), a.end(), &cmp);",
      "    T p1 = a[0], p2 = a.back();",
      "    vector<T> up, down;",
      "    up.push_back(p1);",
      "    down.push_back(p1);",
      "    for (int i = 1; i < (int)a.size(); i++) {",
      "        if (i == a.size() - 1 || cw(p1, a[i], p2)) {",
      "            while (up.size() >= 2 && !cw(up[up.size()-2], up[up.size()-1], a[i]))",
      "                up.pop_back();",
      "            up.push_back(a[i]);",
      "        }",
      "        if (i == a.size() - 1 || ccw(p1, a[i], p2)) {",
      "            while(down.size() >= 2 && !ccw(down[down.size()-2], down[down.size()-1], a[i]))",
      "                down.pop_back();",
      "            down.push_back(a[i]);",
      "        }",
      "    }",
      "",
      "    a.clear();",
      "    for (int i = 0; i < (int)up.size(); i++)",
      "        a.push_back(up[i]);",
      "",
      "    if(sz(a) == tot)",
      "        return;",
      "        ",
      "    for (int i = down.size() - 2; i > 0; i--)",
      "        a.push_back(down[i]);",
      "}"
    ],
    "description": "Convex Hull Graham Scan"
  },
  "Area of a polygon": {
    "prefix": "area",
    "body": [
      "// template <class T> using Polygon = vector<Point<T>>;",
      "inline int prev(int i, int n) { return i == 0 ? n-1 : i-1; }",
      "inline int next(int i, int n) { return i == n-1 ? 0 : i+1; }",
      "",
      "",
      "// **** Returns twice the area ***",
      "// Points of polygon should be in clockwise or anticlockwise direction",
      "template<class T> ll area(const T& poly) { ",
      "    int n = static_cast<int>(poly.size());",
      "    ll area = 0;",
      "    for (int i = 0; i < n; ++i)",
      "        area += poly[i].x_cord * (poly[next(i, n)].y_cord - poly[prev(i, n)].y_cord);",
      "    return abs(area);",
      "}",
      ""
    ],
    "description": "Area of a polygon"
  },


//////////////// MATHEMATICS ///////////////////////

  "Get divisors of a number": {
    "prefix": "divisors",
    "body": [
      "vector<ll> divisors(ll n)",
      "{",
      "    vector<ll> v;",
      "    for(int i=1;i*i<=n;i++)",
      "    {",
      "        if(n%i == 0)",
      "        {",
      "            v.push_back(i);",
      "            if(i != n/i)",
      "                v.push_back(n/i);",
      "        }",
      "    }",
      "",
      "    sort(all(v));",
      "",
      "    return v;       ",
      "}",
      ""
    ],
    "description": "Get divisors of a number"
  },
  "all divisors": {
    "prefix": "all divisors",
    "body": [
      "#define ALL_DIVISORS",
      "#define DIVISOR_N MX",
      "vector <int> divs[DIVISOR_N];",
      "void alldivisors()",
      "{",
      "  for(int i = 1; i < DIVISOR_N; i++)",
      "    for(int j=i;j<DIVISOR_N;j+=i)",
      "      divs[j].pb(i);",
      "}",
    ],
    "description": "all divisors"
  },

  
  "Prime Factorization of a number": {
    "prefix": "prime factorization",
    "body": [
      "// import linear_sieve",
      "pair<map<ll, int>, vector<ll>> fast_prime_factorization(ll n)",
      "{",
      "    map<ll, int> ret;",
      "    vector<ll> ret2;",
      "    while(n != 1)",
      "    {",
      "        ret[lp[n]]++;",
      "        n /= lp[n];",
      "    }",
      "    for(auto i: ret)",
      "        ret2.push_back(power(i.first, i.second));",
      "",
      "    return {ret, ret2};",
      "}",
      "",
      "",
      "pair<map<ll, int>, vector<ll>> slow_prime_factorization(ll n)",
      "{",
      "    map<ll, int> ret1;",
      "    vector<ll> ret2;",
      "",
      "    int cnt = 0;",
      "    for(int i: pr)",
      "    {",
      "        if(i*i > n)",
      "            break;",
      "",
      "        if(n < FSIEVE) {",
      "            for(auto &j: fast_prime_factorization(n).first) {",
      "                ret1[j.first] += j.second;",
      "            }",
      "            n = 1;",
      "            break;",
      "        }",
      "",
      "        cnt = 0;",
      "        if(n%i == 0)",
      "        {",
      "            while(n%i == 0)",
      "                cnt++, n/=i;",
      "            ret1[i] = cnt;",
      "        }",
      "    }",
      "    if(n > 1)",
      "        ret1[n] = 1;",
      "",
      "    for(auto i: ret1)",
      "        ret2.push_back(power(i.first, i.second));",
      "",
      "    return {ret1, ret2};",
      "} ",
      "",
      "",
      "pair<map<ll, int>, vector<ll>> prime_factorization(ll n) {",
      "    if(n < FSIEVE)",
      "        return fast_prime_factorization(n);",
      "    return slow_prime_factorization(n);",
      "}",
      "",
      ""
    ],
    "description": "Prime Factorization of a number"
  },

  "Gets totient value of a number": {
    "prefix": "totient n",
    "body": [
      "",
      "// import prime factorization",
      "ll totient(ll n)",
      "{",
      "    ll ret = n;",
      "    for(auto j: prime_factorization(n).first)",
      "        ret -= ret/j.first;",
      "    return ret;",
      "}",
      ""
    ],
    "description": "Gets totient value of a number"
  },
  "totient seive": {
    "prefix": "totient sieve",
    "body": [
      "define TOTIENT_SIEVE",
      "#define TMAX MX",
      "int phi[TMAX+1];",
      "void totient_sieve() ",
      "{",
      "    phi[0] = 0;",
      "    phi[1] = 1;",
      "    for (int i = 2; i <= TMAX; i++)",
      "        phi[i] = i;",
      "",
      "    for (int i = 2; i <= TMAX; i++) ",
      "    {",
      "        if (phi[i] == i) ",
      "        {",
      "            for (int j = i; j <= TMAX; j += i)",
      "                phi[j] -= phi[j] / i;",
      "        }",
      "    }",
      "}",
    ],
    "description": "totient seive"
  },


  "mobius of a number": {
    "prefix": "mobius",
    "body": [
      "// import linear sieve",
      "ll mobius (ll n)",
      "{",
      "    ll count=0;",
      "    for(auto j:pr)",
      "    {",
      "        if(n%j==0)",
      "        {",
      "            n/=j;",
      "            ++count;",
      "            if(n%j==0)",
      "                return 0;",
      "        }",
      "    }",
      "    if(count&1)return -1;",
      "    else return 1;",
      "}",
      "",
      ""
    ],
    "description": "mobius of a number"
  },
  "multiplicative functions": {
    "prefix": "multiplicative functions",
    "body": [
      "// import LINEAR SIEVE and PRIME FACTORIZATION",
      "int ${1:mobius}[FSIEVE + 1];",
      "",
      "int get_val_${1:mobius}(int n)",
      "{",
      "    auto i = prime_factorization(n);",
      "    if(sz(i.second) == 1)",
      "    {",
      "        // define behaviour of multiplicative function",
      "        // on p^k",
      "",
      "        int p = i.first.begin()->first, k = i.first.begin()->second;",
      "",
      "        if(k > 1)",
      "            return 0;",
      "        return -1;",
      "    }",
      "",
      "    int ret = 1;",
      "    for(int i: i.second)",
      "        ret *= ${1:mobius}[i];",
      "    return ret;",
      "}",
      "",
      "",
      "#define MOBIUS",
      "// import linear_sieve and prime factorization",
      "void calc_${1:mobius}()",
      "{",
      "    ${1:mobius}[1] = 1;",
      "    for(int i=2;i<=FSIEVE;i++)",
      "        ${1:mobius}[i] = get_val_${1:mobius}(i);",
      "}",
      "",
      "",
      ""
    ],
    "description": "multiplicative functions"
  },


  "linear_sieve": {
    "prefix": "linear sieve",
    "body": [
      "#define LINEAR_SIEVE",
      "#define FSIEVE MX",
      "",
      "int lp[FSIEVE+1];",
      "vector <int> pr;",
      "void linear_sieve()",
      "{",
      "    for (int i=2; i<=FSIEVE; ++i) ",
      "    {",
      "        if (lp[i] == 0) ",
      "        {",
      "            lp[i] = i;",
      "            pr.push_back (i);",
      "        }",
      "        for (int j=0; j<(int)pr.size() && pr[j]<=lp[i] && i*pr[j]<=FSIEVE; ++j)",
      "            lp[i * pr[j]] = pr[j];",
      "    }",
      "}"
    ],
    "description": ""
  },
  "Finds prime number in ranges": {
    "prefix": "segmented sieve",
    "body": [
      "pair<vector<ll>, vector<bool>>  segmented_sieve(ll l,ll r)",
      "{",
      "    int upto = sqrtl(r) + 5;",
      "    ",
      "",
      "    bool prime[upto]{};",
      "    vector<bool> segment(r-l+1, true);",
      "    vector<ll> primes;",
      "",
      "    memset(prime, true, upto);",
      "",
      "",
      "    prime[0] = prime[1] = false;",
      "    for(int i=2;i<upto;i++)",
      "    {",
      "        if(prime[i])",
      "        {",
      "            for(int j = i*i; j<upto ; j+= i)",
      "                prime[j] = false;",
      "",
      "            for(int j = l + mod(-l, i); j<=r; j+=i)",
      "                segment[j-l] = false;",
      "        }",
      "    }",
      "    for(int i=max(2, l);i<min(upto, r+1);i++)",
      "        segment[i-l] = prime[i];",
      "",
      "    for(int i=0;i<sz(segment);i++)",
      "        if(segment[i])",
      "            primes.push_back(i+l);",
      "",
      "    return {primes, segment};",
      "        ",
      "}",
      ""
    ],
    "description": "Finds prime number in ranges"
  },
  "Checks whether given number is prime or not": {
    "prefix": "is prime",
    "body": [
      "",
      "bool is_prime(ll x)",
      "{",
      "    for(ll i=2;i*i<=x;i++)",
      "        if(x % i == 0)",
      "            return false;",
      "    return true;",
      "}",
      "",
      ""
    ],
    "description": "Checks whether given number is prime or not"
  },

  "Next smaller element and more...": {
    "prefix": "nse",
    "body": [
      "vector<int> NSE(vector<int> &v) {",
      "",
      "    int n = v.size();",
      "    stack<pair<int, int>> s;",
      "    vector<int> nse(n, -1);",
      "",
      "    for(int i=0;i<n;++i) {",
      "        if(s.empty())",
      "            s.push({v[i], i});",
      "        else {",
      "            while(!s.empty() && s.top().first > v[i]) {",
      "                nse[s.top().second] = i;",
      "                s.pop();",
      "            }",
      "            s.push({v[i], i});",
      "        }",
      "    }",
      "    return nse;",
      "}",
      "",
      "vector<int> NGE(vector<int> &v) {",
      "",
      "    int n = v.size();",
      "    stack<pair<int, int>> s;",
      "    vector<int> nge(n, -1);",
      "",
      "    for(int i=0;i<n;++i) {",
      "        if(s.empty())",
      "            s.push({v[i], i});",
      "        else {",
      "            while(!s.empty() && s.top().first < v[i]) {",
      "                nge[s.top().second] = i;",
      "                s.pop();",
      "            }",
      "            s.push({v[i], i});",
      "        }",
      "    }",
      "    return nge;",
      "}",
      "",
      "vector<int> PSE(vector<int> v) {",
      "    reverse(v.begin(), v.end());",
      "    vector<int> pse = NSE(v);",
      "    reverse(pse.begin(), pse.end());",
      "",
      "    int n = pse.size();",
      "    for(int &i: pse)",
      "        if(i != -1)",
      "            i = n - i - 1;",
      "    return pse;",
      "}",
      "",
      "vector<int> PGE(vector<int> v) {",
      "    reverse(v.begin(), v.end());",
      "    vector<int> pge = NGE(v);",
      "    reverse(pge.begin(), pge.end());",
      "",
      "    int n = pge.size();",
      "    for(int &i: pge)",
      "        if(i != -1)",
      "            i = n - i - 1;",
      "    ",
      "    return pge;",
      "}",
      ""
    ],
    "description": "Next smaller element and more..."
  },


  "sum of digits of a number": {
    "prefix": "sum of digits",
    "body": [
      "// write condition for n < 0",
      "int sum_of_digits(ll n)",
      "{",
      "    if(n < 0) n=0;",
      "    int sm = 0;",
      "    while(n)",
      "    {",
      "        sm += n%10;",
      "        n/=10;",
      "    }",
      "    return sm;",
      "}"
    ],
    "description": "sum of digits of a number"
  },


  "Mod inverse": {
    "prefix": "mod inverse",
    "body": [
      "",
      "inline ll mod_inverse(ll x, ll m=hell)",
      "{",
      "    return power(x, m-2, m);",
      "}"
    ],
    "description": "Mod inverse"
  },


  "all Factorials": {
    "prefix": "factorials",
    "body": [
      "#define ALL_FACTORIAL",
      "#define FACTN MX",
      "ll fact[FACTN+1];",
      "",
      "void factcalc()",
      "{",
      "  fact[0] = fact[1] = 1;",
      "  for(int i=2;i<=FACTN;i++)",
      "    fact[i] = mod(fact[i-1]*i);",
      "}",
      "",
      "",
    ],
    "description": "Preprocess all Factorials"
  },
  "Inverse Factorials": {
    "prefix": "inverse factorials",
    "body": [
      "",
      "// import FACTORIALS and MOD INVERSE",
      "",
      "#define INVERSEFACT",
      "ll invfact[FACTN+1];",
      "void inv_factcalc()",
      "{",
      "    for(int i=0;i<=FACTN;i++)",
      "        invfact[i] = mod_inverse(fact[i]);",
      "}",
      ""
    ],
    "description": "Inverse Factorials"
  },
  "NCR calculator": {
    "prefix": "ncr",
    "body": [
      "",
      "// import FACTORIAL and MOD INVERSE or INVERSE FACTORIALS",
      "ll ncr(int n, int r)",
      "{",
      "    if(n < r || n < 0 || r < 0)",
      "        return 0;",
      "    #ifdef INVERSEFACT",
      "    return mod(fact[n] * mod(invfact[r] * invfact[n-r]));",
      "    #else",
      "    return mod(fact[n] * mod(mod_inverse(fact[n-r]) * mod_inverse(fact[r])));",
      "    #endif",
      "}"
    ],
    "description": "NCR calculator"
  },



  "Discrete Logarithm": {
    "prefix": "discrete log",
    "body": [
      "// Returns minimum x for which a ^ x % m = b % m.",
      "int discrete_log(int a, int b, int m) {",
      "    if (a == 0)",
      "        return b == 0 ? 1 : -1;",
      "    a %= m, b %= m;",
      "    int k = 1, add = 0, g;",
      "    while ((g = __gcd(a, m)) > 1) {",
      "        if (b == k)",
      "            return add;",
      "        if (b % g)",
      "            return -1;",
      "        b /= g, m /= g, ++add;",
      "        k = (k * 1ll * a / g) % m;",
      "    }",
      "",
      "    int n = sqrt(m) + 1;",
      "    int an = 1;",
      "    for (int i = 0; i < n; ++i)",
      "        an = (an * 1ll * a) % m;",
      "",
      "    unordered_map<int, int> vals;",
      "    for (int q = 0, cur = b; q <= n; ++q) {",
      "        vals[cur] = q;",
      "        cur = (cur * 1ll * a) % m;",
      "    }",
      "",
      "    for (int p = 1, cur = k; p <= n; ++p) {",
      "        cur = (cur * 1ll * an) % m;",
      "        if (vals.count(cur)) {",
      "            int ans = n * p - vals[cur] + add;",
      "            return ans;",
      "        }",
      "    }",
      "    return -1;",
      "}",
      ""
    ],
    "description": "Discrete Logarithm"
  },
  "Gets first n digits of evaluated expression": {
    "prefix": "first n",
    "body": [
      "// finds first n digits of x*k",
      "// can find it for any expression",
      "inline ll first_n(ll x, ll k, int n)",
      "{",
      "    ld t = k*log10(x);",
      "    return (ll)pow(10, t-(ll)t+n-1);",
      "}",
      ""
    ],
    "description": "Gets first n digits of evaluated expression"
  },

  "Counts the number of inversions": {
    "prefix": "count inversion",
    "body": [
      "template <class SrcIt, class DstIt>",
      "long long count_inversions(SrcIt src_st, SrcIt src_en, DstIt dst_st, DstIt dst_en) {",
      "  int n = src_en - src_st;",
      "  if (n <= 1) return 0;",
      "  int mid = (n - 1) / 2; long long ret = 0;",
      "  ret += count_inversions(dst_st, dst_st + mid + 1, src_st, src_st + mid + 1);",
      "  ret += count_inversions(dst_st + mid + 1, dst_en, src_st + mid + 1, src_en);",
      "  for (int i = 0, j = mid + 1, k = 0; k < n; k++) {",
      "    if (i > mid) dst_st[k] = src_st[j++];",
      "    else if (j >= n) { dst_st[k] = src_st[i++]; ret += j - (mid + 1); }",
      "    else if (src_st[j] < src_st[i]) { dst_st[k] = src_st[j++]; ret += mid + 1 - i; }",
      "    else { dst_st[k] = src_st[i++]; ret += j - (mid + 1); }",
      "  }",
      "  return ret;",
      "}",
      " ",
      "template <class It> long long count_inversions(It st, It en) {",
      "  typedef typename std::iterator_traits<It>::value_type T;",
      "  int n = en - st; T *aux = new T[n];",
      "  for (int i = 0; i < n; i++) aux[i] = st[i];",
      "  long long ret = count_inversions(aux, aux + n, st, en);",
      "  delete[] (aux);",
      "  return ret / 2;",
      "}"
    ],
    "description": "Counts the number of inversions"
  },


////////////// MATHS TEMPLATES ///////////////

  "Matrix Template": {
    "prefix": "matrix",
    "body": [
      "template <class T> struct Matrix {",
      "    vector<vector<T>> A;",
      "",
      "    Matrix() {}",
      "",
      "    Matrix(size_t n, size_t m, bool read = false) : A(n, vector<T>(m, 0)) {if(read) getI();}",
      "",
      "    Matrix(size_t n, bool read = false) : A(n, vector<T>(n, 0)){if(read) getI();};",
      "",    
      "    Matrix(const vector<vector<T>> &v) : A(v) {};",
      "",
      "    Matrix(initializer_list<initializer_list<T>> &v) : A(v) {};",
      "",
      "    size_t height() const { return (A.size()); }",
      "",
      "    size_t width() const { return (A[0].size()); }",
      "",
      "",
      "",
      "    inline const vector<T> &operator[](int k) const { return (A.at(k)); }",
      "",
      "    inline vector<T> &operator[](int k) { return (A.at(k)); }",
      "",
      "    static Matrix I(size_t n) {",
      "        Matrix mat(n);",
      "        for(int i = 0; i < n; i++) mat[i][i] = 1;",
      "        return (mat);",
      "    }",
      "",
      "    Matrix<T> Trans() {",
      "        size_t n = height(), m = width();",
      "        Matrix<T> res(m, n);",
      "        for(int i = 0; i < n; ++i)",
      "            for(int j = 0; j < m; ++j)",
      "                res.A[j][i] = A[i][j];",
      "        ",
      "        return res;",
      "    }",
      "",
      "    Matrix &operator+=(const Matrix &B) {",
      "        size_t n = height(), m = width();",
      "        assert(n == B.height() && m == B.width());",
      "        for(int i = 0; i < n; i++)",
      "            for(int j = 0; j < m; j++) (*this)[i][j] += B[i][j];",
      "        return (*this);",
      "    }",
      "",
      "    Matrix &operator-=(const Matrix &B) {",
      "        size_t n = height(), m = width();",
      "        assert(n == B.height() && m == B.width());",
      "        for(int i = 0; i < n; i++)",
      "            for(int j = 0; j < m; j++) (*this)[i][j] -= B[i][j];",
      "        return (*this);",
      "    }",
      "",
      "    Matrix &operator*=(const Matrix &B) {",
      "        size_t n = height(), m = B.width(), p = width();",
      "        assert(p == B.height());",
      "        vector<vector<T>> C(n, vector<T>(m, 0));",
      "        for(int i = 0; i < n; i++)",
      "            for(int j = 0; j < m; j++)",
      "                for(int k = 0; k < p; k++) C[i][j] = (C[i][j] + ((*this)[i][k] * B[k][j]));",
      "        A.swap(C);",
      "        return (*this);",
      "    }",
      "",
      "    Matrix &operator^=(long long k) {",
      "        Matrix B = Matrix::I(height());",
      "        while(k > 0) {",
      "            if(k & 1) B *= *this;",
      "            *this *= *this;",
      "            k >>= 1LL;",
      "        }",
      "        A.swap(B.A);",
      "        return (*this);",
      "    }",
      "",
      "    Matrix &operator *= (const T &x) {",
      "        size_t n = height(), m = width();",
      "        for (int i = 0; i < n; ++i) {",
      "            for (int j = 0; j < m; ++j) {",
      "                A[i][j] *= x;",
      "            }",
      "        }",
      "        return *this;",
      "    }",
      " ",
      "    Matrix &operator /= (const T &x) {",
      "        size_t n = height(), m = width();",
      "        for (int i = 0; i < n; ++i) {",
      "            for (int j = 0; j < m; ++j) {",
      "                A[i][j] /= x;",
      "            }",
      "        }",
      "        return *this;",
      "    }",
      "",
      "    Matrix operator+(const Matrix &B) const { return (Matrix(*this) += B); }",
      "",
      "    Matrix operator-(const Matrix &B) const { return (Matrix(*this) -= B); }",
      "",
      "    Matrix operator*(const Matrix &B) const { return (Matrix(*this) *= B); }",
      "",
      "    Matrix operator/(const T &x)      const { return (Matrix(*this) /= x); } ",
      "",
      "    Matrix operator*(const T &x)      const { return (Matrix(*this) *= x); }",
      "",
      "    Matrix operator^(const long long k) const { return (Matrix(*this) ^= k); }",
      "",
      "    friend ostream &operator<<(ostream &os, Matrix &p) {",
      "        size_t n = p.height(), m = p.width();",
      "        for(int i = 0; i < n; i++) {",
      "            os << \"[\";",
      "            for(int j = 0; j < m; j++) { os << p[i][j] << (j + 1 == m ? \"]\\n\" : \",\"); }",
      "        }",
      "        return (os);",
      "    }",
      "",
      "    // DOESNOT WORK FOR INT, AS IT INVOLVES DIVISION",
      "    T determinant() {",
      "        size_t n = height();",
      "        Matrix B(*this);",
      "        assert(width() == height());",
      "        T ret = 1;",
      "        for(int i = 0; i < n; i++) {",
      "            int idx = -1;",
      "            for(int j = i; j < n; j++) {",
      "                if(B[j][i] != 0) idx = j;",
      "            }",
      "            if(idx == -1) return (0);",
      "            if(i != idx) {",
      "                ret *= -1;",
      "                swap(B[i], B[idx]);",
      "            }",
      "            ret *= B[i][i];",
      "            T vv = B[i][i];",
      "            for(int j = 0; j < n; j++) { B[i][j] /= vv; }",
      "            for(int j = i + 1; j < n; j++) {",
      "                T a = B[j][i];",
      "                for(int k = 0; k < n; k++) { B[j][k] -= B[i][k] * a; }",
      "            }",
      "        }",
      "        return (ret);",
      "    }",
      "",
      "    void getI() {",
      "    size_t n = height(), m = width();",
      "    for(int i = 0; i < n; ++i)",
      "        for(int j = 0; j < m; ++j )",
      "            cin >> A[i][j];",
      "    }",
      "",
      "",
      "};",
      ""
    ],
    "description": "Matrix Template"
  },
  "Modular integer": {
    "prefix": "mint",
    "body": [
      "namespace modular {",
      "    constexpr ll MOD = hell;",
      "    template <ll Modulus> class modint;",
      "    #define mint modint<MOD>",
      "    #define vmint vector<mint>",
      "    mint inv(int x);",
      "",
      "    template <ll Modulus> class modint {",
      "",
      "    public:",
      "        static constexpr int mod() { return Modulus; }",
      "        ll a;",
      "",
      "        constexpr modint(const ll x = 0) noexcept : a(((x % Modulus) + Modulus) % Modulus) {}",
      "        constexpr ll &value() noexcept { return a; }",
      "        constexpr const ll &value() const noexcept { return a; }",
      "        constexpr modint operator-() const noexcept { return modint() - *this; }",
      "        constexpr modint operator+() const noexcept { return *this; }",
      "        constexpr modint &operator++() noexcept {",
      "            if(++a == MOD) a = 0;",
      "            return *this;",
      "        }",
      "        constexpr modint &operator--() noexcept {",
      "            if(!a) a = MOD;",
      "            a--;",
      "            return *this;",
      "        }",
      "        constexpr modint operator++(int) {",
      "            modint res = *this;",
      "            ++*this;",
      "            return res;",
      "        }",
      "        constexpr modint operator--(int) {",
      "            mint res = *this;",
      "            --*this;",
      "            return res;",
      "        }",
      "        constexpr modint &operator+=(const modint rhs) noexcept {",
      "            a += rhs.a;",
      "            if(a >= Modulus) { a -= Modulus; }",
      "            return *this;",
      "        }",
      "        constexpr modint &operator-=(const modint rhs) noexcept {",
      "            if(a < rhs.a) { a += Modulus; }",
      "            a -= rhs.a;",
      "            return *this;",
      "        }",
      "        constexpr modint &operator*=(const modint rhs) noexcept {",
      "            a = a * rhs.a % Modulus;",
      "            return *this;",
      "        }",
      "        constexpr modint &operator/=(const modint rhs) noexcept {",
      "            a = a * (modular::inv(rhs.a)).a % Modulus;",
      "            return *this;",
      "        }",
      "        constexpr modint pow(long long n) const noexcept {",
      "            if(n < 0) {",
      "                n %= Modulus - 1;",
      "                n = (Modulus - 1) + n;",
      "            }",
      "            modint x = *this, r = 1;",
      "            while(n) {",
      "                if(n & 1) r *= x;",
      "                x *= x;",
      "                n >>= 1;",
      "            }",
      "            return r;",
      "        }",
      "        constexpr modint inv() const noexcept { return pow(Modulus - 2); }",
      "        constexpr friend modint operator+(const modint &lhs, const modint &rhs) { return modint(lhs) += modint(rhs); }",
      "        constexpr friend modint operator-(const modint &lhs, const modint &rhs) { return modint(lhs) -= modint(rhs); }",
      "        constexpr friend modint operator*(const modint &lhs, const modint &rhs) { return modint(lhs) *= modint(rhs); }",
      "        constexpr friend modint operator/(const modint &lhs, const modint &rhs) { return modint(lhs) /= modint(rhs); }",
      "        constexpr friend bool operator==(const modint &lhs, const modint &rhs) { return lhs.a == rhs.a; }",
      "        constexpr friend bool operator!=(const modint &lhs, const modint &rhs) { return lhs.a != rhs.a; }",
      "        // constexpr friend modint operator^=(const modint &lhs, const modint &rhs) { return modint(lhs) ^= modint(rhs); }",
      "    };",
      "",
      "    ostream &operator<<(ostream &os, mint a) {",
      "        os << a.a;",
      "        return os;",
      "    }",
      "    istream &operator>>(istream &is, mint &a) {",
      "        ll x;",
      "        is >> x;",
      "        a = x;",
      "        return is;",
      "    }",
      "",
      "    mint inv(int n)",
      "    {",
      "        return (mint(n).pow(MOD-2));",
      "    }",
      "",
      "}",
      "using namespace modular;",
      ""
    ],
    "description": "Modular integer"
  },
  "Second Modular Template": {
    "prefix": "Mint",
    "body": [
      "",
      "struct Mint {",
      "    int val, MOD = hell;",
      "",
      "    Mint(long long v = 0) {",
      "        if (v < 0)",
      "            v = v % MOD + MOD;",
      "        if (v >= MOD)",
      "            v %= MOD;",
      "        val = v;",
      "    }",
      "    explicit operator int() const {",
      "        return val;",
      "    }",
      "    Mint& operator+=(const Mint &other) {",
      "        assert(MOD == other.MOD);",
      "        val += other.val;",
      "        if (val >= MOD) val -= MOD;",
      "        return *this;",
      "    }",
      "    Mint& operator-=(const Mint &other) {",
      "        assert(MOD == other.MOD);",
      "        val -= other.val;",
      "        if (val < 0) val += MOD;",
      "        return *this;",
      "    }",
      "    ll fast_mod(uint64_t x) {",
      "        return x % MOD;",
      "    }",
      "    Mint& operator*=(const Mint &other) {",
      "        assert(MOD == other.MOD);",
      "        val = fast_mod((uint64_t) val * other.val);",
      "        return *this;",
      "    }",
      "    Mint& operator/=(const Mint &other) {",
      "        assert(MOD == other.MOD);",
      "        return *this *= other.inv();",
      "    }",
      "    friend Mint operator+(const Mint &a, const Mint &b) { return Mint(a) += b; }",
      "    friend Mint operator-(const Mint &a, const Mint &b) { return Mint(a) -= b; }",
      "    friend Mint operator*(const Mint &a, const Mint &b) { return Mint(a) *= b; }",
      "    friend Mint operator/(const Mint &a, const Mint &b) { return Mint(a) /= b; }",
      "    Mint& operator++() {",
      "        val = val == MOD - 1 ? 0 : val + 1;",
      "        return *this;",
      "    }",
      "    Mint& operator--() {",
      "        val = val == 0 ? MOD - 1 : val - 1;",
      "        return *this;",
      "    }",
      "    Mint operator++(int32_t) { Mint before = *this; ++*this; return before; }",
      "    Mint operator--(int32_t) { Mint before = *this; --*this; return before; }",
      "    Mint operator-() const {",
      "        return val == 0 ? 0 : MOD - val;",
      "    }",
      "    bool operator==(const Mint &other) const { return val == other.val; }",
      "    bool operator!=(const Mint &other) const { return val != other.val; }",
      "    Mint inv() const {",
      "        return (Mint)mod_inverse(val, MOD);",
      "    }",
      "    Mint power(long long p) const {",
      "        assert(p >= 0);",
      "        Mint a = *this, result = 1;",
      "        while (p > 0) {",
      "            if (p & 1)",
      "                result *= a;",
      " ",
      "            a *= a;",
      "            p >>= 1;",
      "        }",
      "        return result;",
      "    }",
      "    friend ostream& operator << (ostream &stream, const Mint &m) {",
      "        return stream << m.val;",
      "    }",
      "    friend istream& operator >> (istream &stream, Mint &m) {",
      "        return stream>>m.val;   ",
      "    }",
      "};",
      ""
    ],
    "description": "Second Modular Template"
  },

////////////// SPECIAL ALGORITHMS ///////////////////////////

  "Meet in the middle": {
    "prefix": "mim",
    "body": [
      "ll mim(vector<ll> &v, ll target, bool usemap = false)",
      "{",
      "    int n = sz(v);",
      "    assert(n <= 40);",
      "    int left = n/2, right = n-left;",
      "    ll ans = 0;",
      "",
      "    if(usemap)",
      "    {",
      "        map<ll, int> mp;",
      "        for(int mask=0;mask<1<<left;++mask)",
      "        {",
      "            ll sm = 0;",
      "            for(int i=0;i<left;i++)",
      "                sm += ((mask>>i)&1) * v[i];",
      "            mp[sm]++;",
      "        }",
      "",
      "",
      "        for(int mask=0;mask<1<<right;++mask)",
      "        {",
      "            ll sm = 0;",
      "            for(int i=0;i<right;i++)",
      "                sm += ((mask>>i)&1) * v[i+left];",
      "            ans += mp[target-sm];",
      "        }",
      "    }",
      "    ",
      "    else",
      "    {",
      "        vector<ll> p1, p2;",
      "        for(int mask=0;mask<1<<left;++mask)",
      "        {",
      "            ll sm = 0;",
      "            for(int i=0;i<left;i++)",
      "                sm += ((mask>>i)&1) * v[i];",
      "            p1.push_back(sm);",
      "        }",
      "",
      "",
      "        for(int mask=0;mask<1<<right;++mask)",
      "        {",
      "            ll sm = 0;",
      "            for(int i=0;i<right;i++)",
      "                sm += ((mask>>i)&1) * v[i+left];",
      "            p2.push_back(sm);",
      "        }",
      "",
      "        sort(all(p1)), sort(all(p2));",
      "",
      "        int l = sz(p2), r = sz(p2);",
      "",
      "        EACH(i, p1)",
      "        {",
      "            while(l > 0 && i+p2[l-1] >= target) l--;",
      "            while(r > 0 && i+p2[r-1] > target) r--;",
      "            ans += (r-l);",
      "        }",
      "    }",
      "",
      "",
      "    return ans;",
      "}",
      ""
    ],
    "description": "Meet in the middle"
  },
  "Subset sum using DP": {
    "prefix": "subset_sum",
    "body": [
      "ll subset_sum(vector<ll> &v, int target)",
      "{",
      "    int n = sz(v);",
      "    vector<ll> dp(target+1);",
      "    dp[0] = 1;",
      "    for(int i=0;i<n;++i)",
      "        for(int j=target;j>=0;j--)",
      "            if(j+v[i] <= target)",
      "                dp[j+v[i]] += dp[j];",
      "    return dp[target];",
      "}",
      ""
    ],
    "description": "Subset sum using DP"
  },


/////////////// POLYNOMIAL ////////////////////////


  "NTT": {
        "prefix": "ntt",
        "body": [
          "const int MOD = 998244353;",
          "",
          "struct mod_field {",
          "    int32_t val;",
          "    mod_field(long long v = 0) {if (v < 0) v = v % MOD + MOD; if (v >= MOD) v %= MOD; val = v; }",
          "",
          "    static int32_t mod_inv(int32_t a, int32_t m = MOD) {",
          "        int32_t g = m, r = a, x = 0, y = 1;",
          "        while (r != 0) {",
          "            int32_t q = g / r;",
          "            g %= r; swap(g, r);",
          "            x -= q * y; swap(x, y);",
          "        }",
          "        return x < 0 ? x + m : x;",
          "    }",
          "    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {",
          "        #if !defined(_WIN32) || defined(_WIN64)",
          "        return x % m;",
          "        #endif",
          "        unsigned x_high = x >> 32, x_low = (unsigned) x;",
          "        unsigned quot, rem;",
          "        asm(\"divl %4\\n\"",
          "            : \"=a\" (quot), \"=d\" (rem)",
          "            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));",
          "        return rem;",
          "    }",
          "",
          "    operator int64_t() const {return val; }",
          "    mod_field& operator+=(const mod_field &other) {val += other.val; if (val >= MOD) val -= MOD; return *this; }",
          "    mod_field& operator-=(const mod_field &other) {val -= other.val; if (val < 0) val += MOD; return *this; }",
          "    mod_field& operator*=(const mod_field &other) {val = fast_mod((uint64_t) val * other.val); return *this; }",
          "    mod_field& operator/=(const mod_field &other) {return *this *= other.inv(); }",
          "    friend mod_field operator+(const mod_field &a, const mod_field &b) { return mod_field(a) += b; }",
          "    friend mod_field operator-(const mod_field &a, const mod_field &b) { return mod_field(a) -= b; }",
          "    friend mod_field operator*(const mod_field &a, const mod_field &b) { return mod_field(a) *= b; }",
          "    friend mod_field operator/(const mod_field &a, const mod_field &b) { return mod_field(a) /= b; }",
          "    mod_field& operator++() {val = val == MOD - 1 ? 0 : val + 1; return *this; }",
          "    mod_field& operator--() {val = val == 0 ? MOD - 1 : val - 1; return *this; }",
          "    mod_field operator++(int32_t) { mod_field before = *this; ++*this; return before; }",
          "    mod_field operator--(int32_t) { mod_field before = *this; --*this; return before; }",
          "    mod_field operator-() const {return val == 0 ? 0 : MOD - val; }",
          "    // bool operator==(const mod_field &other) const { return val == other.val; }",
          "    // bool operator!=(const mod_field &other) const { return val != other.val; }",
          "    mod_field inv() const {return mod_inv(val); }",
          "    friend ostream& operator<<(ostream &stream, const mod_field &m) {return stream << m.val; }",
          "    friend istream& operator>>(istream &stream, mod_field &m) {return stream >> m.val; }",
          "",
          "    mod_field pow(long long p) const {",
          "        assert(p >= 0);",
          "        mod_field a = *this, result = 1;",
          "        while (p > 0) {",
          "            if (p & 1)",
          "                result *= a;",
          "            ",
          "            a *= a;",
          "            p >>= 1;",
          "        }",
          "        return result;",
          "    }",
          "};",
          "typedef mod_field base;",
          "typedef mod_field mod_int;",
          "",
          "",
          "namespace algebra {",
          "    const int inf = 1e9;",
          "    const int magic = 200; // threshold for sizes to run the naive algo",
          "    ",
          "    namespace NTT {",
          "    vector<mod_int> roots = {0, 1};",
          "        vector<int> bit_reverse;",
          "        int max_size = -1;",
          "        mod_int root;",
          "     ",
          "        bool is_power_of_two(int n) {",
          "            return (n & (n - 1)) == 0;",
          "        }",
          "     ",
          "        int round_up_power_two(int n) {",
          "            while (n & (n - 1))",
          "                n = (n | (n - 1)) + 1;",
          "     ",
          "            return max(n, 1);",
          "        }",
          "     ",
          "        // Given n (a power of two), finds k such that n == 1 << k.",
          "        int get_length(int n) {",
          "            assert(is_power_of_two(n));",
          "            return __builtin_ctz(n);",
          "        }",
          "     ",
          "        // Rearranges the indices to be sorted by lowest bit first, then second lowest, etc., rather than highest bit first.",
          "        // This makes even-odd div-conquer much easier.",
          "        void bit_reorder(int n, vector<mod_int> &values) {",
          "            if ((int) bit_reverse.size() != n) {",
          "                bit_reverse.assign(n, 0);",
          "                int length = get_length(n);",
          "     ",
          "                for (int i = 0; i < n; i++)",
          "                    bit_reverse[i] = (bit_reverse[i >> 1] >> 1) + ((i & 1) << (length - 1));",
          "            }",
          "     ",
          "            for (int i = 0; i < n; i++)",
          "                if (i < bit_reverse[i])",
          "                    swap(values[i], values[bit_reverse[i]]);",
          "        }",
          "     ",
          "        void find_root() {",
          "            max_size = 1 << __builtin_ctz(MOD - 1);",
          "            root = 2;",
          "     ",
          "            // Find a max_size-th primitive root of MOD.",
          "            while (!(root.pow(max_size) == 1 && root.pow(max_size / 2) != 1))",
          "                root++;",
          "        }",
          "     ",
          "        void prepare_roots(int n) {",
          "            if (max_size < 0)",
          "                find_root();",
          "     ",
          "            assert(n <= max_size);",
          "     ",
          "            if ((int) roots.size() >= n)",
          "                return;",
          "     ",
          "            int length = get_length(roots.size());",
          "            roots.resize(n);",
          "     ",
          "            // The roots array is set up such that for a given power of two n >= 2, roots[n / 2] through roots[n - 1] are",
          "            // the first half of the n-th primitive roots of MOD.",
          "            while (1 << length < n) {",
          "                // z is a 2^(length + 1)-th primitive root of MOD.",
          "                mod_int z = root.pow(max_size >> (length + 1));",
          "     ",
          "                for (int i = 1 << (length - 1); i < 1 << length; i++) {",
          "                    roots[2 * i] = roots[i];",
          "                    roots[2 * i + 1] = roots[i] * z;",
          "                }",
          "     ",
          "                length++;",
          "            }",
          "        }",
          "     ",
          "        void fft_iterative(int N, vector<mod_int> &values) {",
          "            assert(is_power_of_two(N));",
          "            prepare_roots(N);",
          "            bit_reorder(N, values);",
          "     ",
          "            for (int n = 1; n < N; n *= 2)",
          "                for (int start = 0; start < N; start += 2 * n)",
          "                    for (int i = 0; i < n; i++) {",
          "                        mod_int even = values[start + i];",
          "                        mod_int odd = values[start + n + i] * roots[n + i];",
          "                        values[start + n + i] = even - odd;",
          "                        values[start + i] = even + odd;",
          "                    }",
          "        }",
          "     ",
          "        const int FFT_CUTOFF = magic;",
          "     ",
          "        vector<mod_int> mod_multiply(vector<mod_int> left, vector<mod_int> right) {",
          "            int n = left.size();",
          "            int m = right.size();",
          "     ",
          "            // Brute force when either n or m is small enough.",
          "            if (min(n, m) < FFT_CUTOFF) {",
          "                const uint64_t ULL_BOUND = numeric_limits<uint64_t>::max() - (uint64_t) MOD * MOD;",
          "                vector<uint64_t> result(n + m - 1, 0);",
          "     ",
          "                for (int i = 0; i < n; i++)",
          "                    for (int j = 0; j < m; j++) {",
          "                        result[i + j] += (uint64_t) ((int) left[i]) * ((int) right[j]);",
          "     ",
          "                        if (result[i + j] > ULL_BOUND)",
          "                            result[i + j] %= MOD;",
          "                    }",
          "     ",
          "                for (uint64_t &x : result)",
          "                    if (x >= MOD)",
          "                        x %= MOD;",
          "     ",
          "                return vector<mod_int>(result.begin(), result.end());",
          "            }",
          "     ",
          "            int N = round_up_power_two(n + m - 1);",
          "            left.resize(N);",
          "            right.resize(N);",
          "     ",
          "            bool equal = left == right;",
          "            fft_iterative(N, left);",
          "     ",
          "            if (equal)",
          "                right = left;",
          "            else",
          "                fft_iterative(N, right);",
          "     ",
          "            mod_int inv_N = mod_int(N).inv();",
          "     ",
          "            for (int i = 0; i < N; i++)",
          "                left[i] *= right[i] * inv_N;",
          "     ",
          "            reverse(left.begin() + 1, left.end());",
          "            fft_iterative(N, left);",
          "            left.resize(n + m - 1);",
          "            return left;",
          "        }",
          "        template<typename T>",
          "        void mul(vector<T> &a,const vector<T> &b){",
          "            a = mod_multiply(a,b);",
          "        }",
          "    }",
          "    ",
          "    ",
          "    template<typename T>",
          "    struct poly {",
          "        vector<T> a;",
          "        ",
          "        void normalize() { // get rid of leading zeroes",
          "            while(!a.empty() && a.back() == T(0)) {",
          "                a.pop_back();",
          "            }",
          "        }",
          "        ",
          "        poly(){}",
          "        poly(T a0) : a{a0}{normalize();}",
          "        poly(vector<T> t) : a(t){normalize();}",
          "        ",
          "        poly operator += (const poly &t) {",
          "            a.resize(max(a.size(), t.a.size()));",
          "            for(size_t i = 0; i < t.a.size(); i++) {",
          "                a[i] += t.a[i];",
          "            }",
          "            normalize();",
          "            return *this;",
          "        }",
          "        poly operator -= (const poly &t) {",
          "            a.resize(max(a.size(), t.a.size()));",
          "            for(size_t i = 0; i < t.a.size(); i++) {",
          "                a[i] -= t.a[i];",
          "            }",
          "            normalize();",
          "            return *this;",
          "        }",
          "        poly operator + (const poly &t) const {return poly(*this) += t;}",
          "        poly operator - (const poly &t) const {return poly(*this) -= t;}",
          "        ",
          "        poly mod_xk(size_t k) const { // get same polynomial mod x^k",
          "            k = min(k, a.size());",
          "            return vector<T>(begin(a), begin(a) + k);",
          "        }",
          "        poly mul_xk(size_t k) const { // multiply by x^k",
          "            poly res(*this);",
          "            res.a.insert(begin(res.a), k, 0);",
          "            return res;",
          "        }",
          "        poly div_xk(size_t k) const { // divide by x^k, dropping coefficients",
          "            k = min(k, a.size());",
          "            return vector<T>(begin(a) + k, end(a));",
          "        }",
          "        poly substr(size_t l, size_t r) const { // return mod_xk(r).div_xk(l)",
          "            l = min(l, a.size());",
          "            r = min(r, a.size());",
          "            return vector<T>(begin(a) + l, begin(a) + r);",
          "        }",
          "        poly inv(size_t n) const { // get inverse series mod x^n",
          "            assert(!is_zero());",
          "            poly ans = a[0].inv();",
          "            size_t a = 1;",
          "            while(a < n) {",
          "                poly C = (ans * mod_xk(2 * a)).substr(a, 2 * a);",
          "                ans -= (ans * C).mod_xk(a).mul_xk(a);",
          "                a *= 2;",
          "            }",
          "            return ans.mod_xk(n);",
          "        }",
          "        ",
          "        poly operator *= (const poly &t) {NTT::mul(a, t.a); normalize(); return *this;}",
          "        poly operator * (const poly &t) const {return poly(*this) *= t;}",
          "        ",
          "        poly reverse(size_t n, bool rev = 0) const { // reverses and leaves only n terms",
          "            poly res(*this);",
          "            if(rev) { // If rev = 1 then tail goes to head",
          "                res.a.resize(max(n, res.a.size()));",
          "            }",
          "            std::reverse(res.a.begin(), res.a.end());",
          "            return res.mod_xk(n);",
          "        }",
          "        ",
          "        pair<poly, poly> divmod_slow(const poly &b) const { // when divisor or quotient is small",
          "            vector<T> A(a);",
          "            vector<T> res;",
          "            while(A.size() >= b.a.size()) {",
          "                res.push_back(A.back() / b.a.back());",
          "                if(res.back() != T(0)) {",
          "                    for(size_t i = 0; i < b.a.size(); i++) {",
          "                        A[A.size() - i - 1] -= res.back() * b.a[b.a.size() - i - 1];",
          "                    }",
          "                }",
          "                A.pop_back();",
          "            }",
          "            std::reverse(begin(res), end(res));",
          "            return {res, A};",
          "        }",
          "        ",
          "        pair<poly, poly> divmod(const poly &b) const { // returns quotiend and remainder of a mod b",
          "            if(deg() < b.deg()) {",
          "                return {poly{0}, *this};",
          "            }",
          "            int d = deg() - b.deg();",
          "            if(min(d, b.deg()) < magic) {",
          "                return divmod_slow(b);",
          "            }",
          "            poly D = (reverse(d + 1) * b.reverse(d + 1).inv(d + 1)).mod_xk(d + 1).reverse(d + 1, 1);",
          "            return {D, *this - D * b};",
          "        }",
          "        ",
          "        poly operator / (const poly &t) const {return divmod(t).first;}",
          "        poly operator % (const poly &t) const {return divmod(t).second;}",
          "        poly operator /= (const poly &t) {return *this = divmod(t).first;}",
          "        poly operator %= (const poly &t) {return *this = divmod(t).second;}",
          "        poly operator *= (const T &x) {",
          "            for(auto &it: a) {",
          "                it *= x;",
          "            }",
          "            normalize();",
          "            return *this;",
          "        }",
          "        poly operator /= (const T &x) {",
          "            for(auto &it: a) {",
          "                it /= x;",
          "            }",
          "            normalize();",
          "            return *this;",
          "        }",
          "        poly operator * (const T &x) const {return poly(*this) *= x;}",
          "        poly operator / (const T &x) const {return poly(*this) /= x;}",
          "        ",
          "        void print() const {",
          "            for(auto it: a) {",
          "                cout << it << ' ';",
          "            }",
          "            cout << endl;",
          "        }",
          "        T eval(T x) const { // evaluates in single point x",
          "            T res(0);",
          "            for(int i = int(a.size()) - 1; i >= 0; i--) {",
          "                res *= x;",
          "                res += a[i];",
          "            }",
          "            return res;",
          "        }",
          "        ",
          "        T& lead() { // leading coefficient",
          "            return a.back();",
          "        }",
          "        int deg() const { // degree",
          "            return a.empty() ? -inf : a.size() - 1;",
          "        }",
          "        bool is_zero() const { // is polynomial zero",
          "            return a.empty();",
          "        }",
          "        T operator [](int idx) const {",
          "            return idx >= (int)a.size() || idx < 0 ? T(0) : a[idx];",
          "        }",
          "        ",
          "        T& coef(size_t idx) { // mutable reference at coefficient",
          "            return a[idx];",
          "        }",
          "        bool operator == (const poly &t) const {return a == t.a;}",
          "        bool operator != (const poly &t) const {return a != t.a;}",
          "        ",
          "        poly deriv() { // calculate derivative",
          "            vector<T> res;",
          "            for(int i = 1; i <= deg(); i++) {",
          "                res.push_back(T(i) * a[i]);",
          "            }",
          "            return res;",
          "        }",
          "        poly integr() { // calculate integral with C = 0",
          "            vector<T> res = {0};",
          "            for(int i = 0; i <= deg(); i++) {",
          "                res.push_back(a[i] / T(i + 1));",
          "            }",
          "            return res;",
          "        }",
          "        size_t leading_xk() const { // Let p(x) = x^k * t(x), return k",
          "            if(is_zero()) {",
          "                return inf;",
          "            }",
          "            int res = 0;",
          "            while(a[res] == T(0)) {",
          "                res++;",
          "            }",
          "            return res;",
          "        }",
          "        poly log(size_t n) { // calculate log p(x) mod x^n",
          "            assert(a[0] == T(1));",
          "            return (deriv().mod_xk(n) * inv(n)).integr().mod_xk(n);",
          "        }",
          "        poly exp(size_t n) { // calculate exp p(x) mod x^n",
          "            if(is_zero()) {",
          "                return T(1);",
          "            }",
          "            assert(a[0] == T(0));",
          "            poly ans = T(1);",
          "            size_t a = 1;",
          "            while(a < n) {",
          "                poly C = ans.log(2 * a).div_xk(a) - substr(a, 2 * a);",
          "                ans -= (ans * C).mod_xk(a).mul_xk(a);",
          "                a *= 2;",
          "            }",
          "            return ans.mod_xk(n);",
          "            ",
          "        }",
          "        poly pow_slow(size_t k, size_t n) { // if k is small",
          "            return k ? k % 2 ? (*this * pow_slow(k - 1, n)).mod_xk(n) : (*this * *this).mod_xk(n).pow_slow(k / 2, n) : T(1);",
          "        }",
          "        poly pow(size_t k, size_t n) { // calculate p^k(n) mod x^n",
          "            if(is_zero()) {",
          "                return *this;",
          "            }",
          "            if(k < magic) {",
          "                return pow_slow(k, n);",
          "            }",
          "            int i = leading_xk();",
          "            T j = a[i];",
          "            poly t = div_xk(i) / j;",
          "            return bpow(j, k) * (t.log(n) * T(k)).exp(n).mul_xk(i * k).mod_xk(n);",
          "        }",
          "        poly mulx(T x) { // component-wise multiplication with x^k",
          "            T cur = 1;",
          "            poly res(*this);",
          "            for(int i = 0; i <= deg(); i++) {",
          "                res.coef(i) *= cur;",
          "                cur *= x;",
          "            }",
          "            return res;",
          "        }",
          "        poly mulx_sq(T x) { // component-wise multiplication with x^{k^2}",
          "            T cur = x;",
          "            T total = 1;",
          "            T xx = x * x;",
          "            poly res(*this);",
          "            for(int i = 0; i <= deg(); i++) {",
          "                res.coef(i) *= total;",
          "                total *= cur;",
          "                cur *= xx;",
          "            }",
          "            return res;",
          "        }",
          "        vector<T> chirpz_even(T z, int n) { // P(1), P(z^2), P(z^4), ..., P(z^2(n-1))",
          "            int m = deg();",
          "            if(is_zero()) {",
          "                return vector<T>(n, 0);",
          "            }",
          "            vector<T> vv(m + n);",
          "            T zi = z.inv();",
          "            T zz = zi * zi;",
          "            T cur = zi;",
          "            T total = 1;",
          "            for(int i = 0; i <= max(n - 1, m); i++) {",
          "                if(i <= m) {vv[m - i] = total;}",
          "                if(i < n) {vv[m + i] = total;}",
          "                total *= cur;",
          "                cur *= zz;",
          "            }",
          "            poly w = (mulx_sq(z) * vv).substr(m, m + n).mulx_sq(z);",
          "            vector<T> res(n);",
          "            for(int i = 0; i < n; i++) {",
          "                res[i] = w[i];",
          "            }",
          "            return res;",
          "        }",
          "        vector<T> chirpz(T z, int n) { // P(1), P(z), P(z^2), ..., P(z^(n-1))",
          "            auto even = chirpz_even(z, (n + 1) / 2);",
          "            auto odd = mulx(z).chirpz_even(z, n / 2);",
          "            vector<T> ans(n);",
          "            for(int i = 0; i < n / 2; i++) {",
          "                ans[2 * i] = even[i];",
          "                ans[2 * i + 1] = odd[i];",
          "            }",
          "            if(n % 2 == 1) {",
          "                ans[n - 1] = even.back();",
          "            }",
          "            return ans;",
          "        }",
          "        template<typename iter>",
          "        vector<T> eval(vector<poly> &tree, int v, iter l, iter r) { // auxiliary evaluation function",
          "            if(r - l == 1) {",
          "                return {eval(*l)};",
          "            } else {",
          "                auto m = l + (r - l) / 2;",
          "                auto A = (*this % tree[2 * v]).eval(tree, 2 * v, l, m);",
          "                auto B = (*this % tree[2 * v + 1]).eval(tree, 2 * v + 1, m, r);",
          "                A.insert(end(A), begin(B), end(B));",
          "                return A;",
          "            }",
          "        }",
          "        vector<T> eval(vector<T> x) { // evaluate polynomial in (x1, ..., xn)",
          "            int n = x.size();",
          "            if(is_zero()) {",
          "                return vector<T>(n, T(0));",
          "            }",
          "            vector<poly> tree(4 * n);",
          "            build(tree, 1, begin(x), end(x));",
          "            return eval(tree, 1, begin(x), end(x));",
          "        }",
          "        template<typename iter>",
          "        poly inter(vector<poly> &tree, int v, iter l, iter r, iter ly, iter ry) { // auxiliary interpolation function",
          "            if(r - l == 1) {",
          "                return {*ly / a[0]};",
          "            } else {",
          "                auto m = l + (r - l) / 2;",
          "                auto my = ly + (ry - ly) / 2;",
          "                auto A = (*this % tree[2 * v]).inter(tree, 2 * v, l, m, ly, my);",
          "                auto B = (*this % tree[2 * v + 1]).inter(tree, 2 * v + 1, m, r, my, ry);",
          "                return A * tree[2 * v + 1] + B * tree[2 * v];",
          "            }",
          "        }",
          "    };",
          "    template<typename T>",
          "    poly<T> operator * (const T& a, const poly<T>& b) {",
          "        return b * a;",
          "    }",
          "    ",
          "    template<typename T>",
          "    poly<T> xk(int k) { // return x^k",
          "        return poly<T>{1}.mul_xk(k);",
          "    }",
          "",
          "    template<typename T>",
          "    T resultant(poly<T> a, poly<T> b) { // computes resultant of a and b",
          "        if(b.is_zero()) {",
          "            return 0;",
          "        } else if(b.deg() == 0) {",
          "            return bpow(b.lead(), a.deg());",
          "        } else {",
          "            int pw = a.deg();",
          "            a %= b;",
          "            pw -= a.deg();",
          "            T mul = bpow(b.lead(), pw) * T((b.deg() & a.deg() & 1) ? -1 : 1);",
          "            T ans = resultant(b, a);",
          "            return ans * mul;",
          "        }",
          "    }",
          "    template<typename iter>",
          "    poly<typename iter::value_type> kmul(iter L, iter R) { // computes (x-a1)(x-a2)...(x-an) without building tree",
          "        if(R - L == 1) {",
          "            return vector<typename iter::value_type>{-*L, 1};",
          "        } else {",
          "            iter M = L + (R - L) / 2;",
          "            return kmul(L, M) * kmul(M, R);",
          "        }",
          "    }",
          "    template<typename T, typename iter>",
          "    poly<T> build(vector<poly<T>> &res, int v, iter L, iter R) { // builds evaluation tree for (x-a1)(x-a2)...(x-an)",
          "        if(R - L == 1) {",
          "            return res[v] = vector<T>{-*L, 1};",
          "        } else {",
          "            iter M = L + (R - L) / 2;",
          "            return res[v] = build(res, 2 * v, L, M) * build(res, 2 * v + 1, M, R);",
          "        }",
          "    }",
          "    template<typename T>",
          "    poly<T> inter(vector<T> x, vector<T> y) { // interpolates minimum polynomial from (xi, yi) pairs",
          "        int n = x.size();",
          "        vector<poly<T>> tree(4 * n);",
          "        return build(tree, 1, begin(x), end(x)).deriv().inter(tree, 1, begin(x), end(x), begin(y), end(y));",
          "    }",
          "};",
          "",
          "using namespace algebra;",
          "",
          "typedef poly<base> polyn;"
        ],
        "description": "gets the template for fft"
  },
  "FFT": {
    "prefix": "fft",
    "body": [
      "namespace algebra {",
      "    const int inf = 1e9;",
      "    const int magic = 500; // threshold for sizes to run the naive algo",
      "    ",
      "    namespace fft {",
      "        const int maxn = 1 << 18;",
      "",
      "        typedef double ftype;",
      "        typedef complex<ftype> point;",
      "",
      "        point w[maxn];",
      "        const ftype pi = acos(-1);",
      "        bool initiated = 0;",
      "        void init() {",
      "            if(!initiated) {",
      "                for(int i = 1; i < maxn; i *= 2) {",
      "                    for(int j = 0; j < i; j++) {",
      "                        w[i + j] = polar(ftype(1), pi * j / i);",
      "                    }",
      "                }",
      "                initiated = 1;",
      "            }",
      "        }",
      "        template<typename T>",
      "        void fft(T *in, point *out, int n, int k = 1) {",
      "            if(n == 1) {",
      "                *out = *in;",
      "            } else {",
      "                n /= 2;",
      "                fft(in, out, n, 2 * k);",
      "                fft(in + k, out + n, n, 2 * k);",
      "                for(int i = 0; i < n; i++) {",
      "                    auto t = out[i + n] * w[i + n];",
      "                    out[i + n] = out[i] - t;",
      "                    out[i] += t;",
      "                }",
      "            }",
      "        }",
      "        ",
      "        template<typename T>",
      "        void mul_slow(vector<T> &a, const vector<T> &b) {",
      "            vector<T> res(a.size() + b.size() - 1);",
      "            for(size_t i = 0; i < a.size(); i++) {",
      "                for(size_t j = 0; j < b.size(); j++) {",
      "                    res[i + j] += a[i] * b[j];",
      "                }",
      "            }",
      "            a = res;",
      "        }",
      "        ",
      "        ",
      "        template<typename T>",
      "        void mul(vector<T> &a, const vector<T> &b) {",
      "            if(min(a.size(), b.size()) < magic) {",
      "                mul_slow(a, b);",
      "                return;",
      "            }",
      "            init();",
      "            static const int shift = 15, mask = (1 << shift) - 1;",
      "            size_t n = a.size() + b.size() - 1;",
      "            while(__builtin_popcount(n) != 1) {",
      "                n++;",
      "            }",
      "            a.resize(n);",
      "            static point A[maxn], B[maxn];",
      "            static point C[maxn], D[maxn];",
      "            for(size_t i = 0; i < n; i++) {",
      "                A[i] = point(a[i] & mask, a[i] >> shift);",
      "                if(i < b.size()) {",
      "                    B[i] = point(b[i] & mask, b[i] >> shift);",
      "                } else {",
      "                    B[i] = 0;",
      "                }",
      "            }",
      "            fft(A, C, n); fft(B, D, n);",
      "            for(size_t i = 0; i < n; i++) {",
      "                point c0 = C[i] + conj(C[(n - i) % n]);",
      "                point c1 = C[i] - conj(C[(n - i) % n]);",
      "                point d0 = D[i] + conj(D[(n - i) % n]);",
      "                point d1 = D[i] - conj(D[(n - i) % n]);",
      "                A[i] = c0 * d0 - point(0, 1) * c1 * d1;",
      "                B[i] = c0 * d1 + d0 * c1;",
      "            }",
      "            fft(A, C, n); fft(B, D, n);",
      "            reverse(C + 1, C + n);",
      "            reverse(D + 1, D + n);",
      "            int t = 4 * n;",
      "            for(size_t i = 0; i < n; i++) {",
      "                int64_t A0 = llround(real(C[i]) / t);",
      "                T A1 = llround(imag(D[i]) / t);",
      "                T A2 = llround(imag(C[i]) / t);",
      "                a[i] = A0 + (A1 << shift) + (A2 << 2 * shift);",
      "            }",
      "            return;",
      "        }",
      "    }",
      "    template<typename T>",
      "    T bpow(T x, size_t n) {",
      "        return n ? n % 2 ? x * bpow(x, n - 1) : bpow(x * x, n / 2) : T(1);",
      "    }",
      "    template<typename T>",
      "    T bpow(T x, size_t n, T m) {",
      "        return n ? n % 2 ? x * bpow(x, n - 1, m) % m : bpow(x * x % m, n / 2, m) : T(1);",
      "    }",
      "    template<typename T>",
      "    T gcd(const T &a, const T &b) {",
      "        return b == T(0) ? a : gcd(b, a % b);",
      "    }",
      "    template<typename T>",
      "    T nCr(T n, int r) { // runs in O(r)",
      "        T res(1);",
      "        for(int i = 0; i < r; i++) {",
      "            res *= (n - T(i));",
      "            res /= (i + 1);",
      "        }",
      "        return res;",
      "    }",
      "",
      "    template<int m>",
      "    struct modular {",
      "        int64_t r;",
      "        modular() : r(0) {}",
      "        modular(int64_t rr) : r(rr) {if(abs(r) >= m) r %= m; if(r < 0) r += m;}",
      "        modular inv() const {return bpow(*this, m - 2);}",
      "        modular operator * (const modular &t) const {return (r * t.r) % m;}",
      "        modular operator / (const modular &t) const {return *this * t.inv();}",
      "        modular operator += (const modular &t) {r += t.r; if(r >= m) r -= m; return *this;}",
      "        modular operator -= (const modular &t) {r -= t.r; if(r < 0) r += m; return *this;}",
      "        modular operator + (const modular &t) const {return modular(*this) += t;}",
      "        modular operator - (const modular &t) const {return modular(*this) -= t;}",
      "        modular operator *= (const modular &t) {return *this = *this * t;}",
      "        modular operator /= (const modular &t) {return *this = *this / t;}",
      "        ",
      "        bool operator == (const modular &t) const {return r == t.r;}",
      "        bool operator != (const modular &t) const {return r != t.r;}",
      "        ",
      "        operator int64_t() const {return r;}",
      "    };",
      "    template<int T>",
      "    istream& operator >> (istream &in, modular<T> &x) {",
      "        return in >> x.r;",
      "    }",
      "    ",
      "    ",
      "    template<typename T>",
      "    struct poly {",
      "        vector<T> a;",
      "        ",
      "        void normalize() { // get rid of leading zeroes",
      "            while(!a.empty() && a.back() == T(0)) {",
      "                a.pop_back();",
      "            }",
      "        }",
      "        ",
      "        poly(){}",
      "        poly(T a0) : a{a0}{normalize();}",
      "        poly(vector<T> t) : a(t){normalize();}",
      "        ",
      "        poly operator += (const poly &t) {",
      "            a.resize(max(a.size(), t.a.size()));",
      "            for(size_t i = 0; i < t.a.size(); i++) {",
      "                a[i] += t.a[i];",
      "            }",
      "            normalize();",
      "            return *this;",
      "        }",
      "        poly operator -= (const poly &t) {",
      "            a.resize(max(a.size(), t.a.size()));",
      "            for(size_t i = 0; i < t.a.size(); i++) {",
      "                a[i] -= t.a[i];",
      "            }",
      "            normalize();",
      "            return *this;",
      "        }",
      "        poly operator + (const poly &t) const {return poly(*this) += t;}",
      "        poly operator - (const poly &t) const {return poly(*this) -= t;}",
      "        ",
      "        poly mod_xk(size_t k) const { // get same polynomial mod x^k",
      "            k = min(k, a.size());",
      "            return vector<T>(begin(a), begin(a) + k);",
      "        }",
      "        poly mul_xk(size_t k) const { // multiply by x^k",
      "            poly res(*this);",
      "            res.a.insert(begin(res.a), k, 0);",
      "            return res;",
      "        }",
      "        poly div_xk(size_t k) const { // divide by x^k, dropping coefficients",
      "            k = min(k, a.size());",
      "            return vector<T>(begin(a) + k, end(a));",
      "        }",
      "        poly substr(size_t l, size_t r) const { // return mod_xk(r).div_xk(l)",
      "            l = min(l, a.size());",
      "            r = min(r, a.size());",
      "            return vector<T>(begin(a) + l, begin(a) + r);",
      "        }",
      "        poly inv(size_t n) const { // get inverse series mod x^n",
      "            assert(!is_zero());",
      "            poly ans = a[0].inv();",
      "            size_t a = 1;",
      "            while(a < n) {",
      "                poly C = (ans * mod_xk(2 * a)).substr(a, 2 * a);",
      "                ans -= (ans * C).mod_xk(a).mul_xk(a);",
      "                a *= 2;",
      "            }",
      "            return ans.mod_xk(n);",
      "        }",
      "        ",
      "        poly operator *= (const poly &t) {fft::mul(a, t.a); normalize(); return *this;}",
      "        poly operator * (const poly &t) const {return poly(*this) *= t;}",
      "        ",
      "        poly reverse(size_t n, bool rev = 0) const { // reverses and leaves only n terms",
      "            poly res(*this);",
      "            if(rev) { // If rev = 1 then tail goes to head",
      "                res.a.resize(max(n, res.a.size()));",
      "            }",
      "            std::reverse(res.a.begin(), res.a.end());",
      "            return res.mod_xk(n);",
      "        }",
      "        ",
      "        pair<poly, poly> divmod_slow(const poly &b) const { // when divisor or quotient is small",
      "            vector<T> A(a);",
      "            vector<T> res;",
      "            while(A.size() >= b.a.size()) {",
      "                res.push_back(A.back() / b.a.back());",
      "                if(res.back() != T(0)) {",
      "                    for(size_t i = 0; i < b.a.size(); i++) {",
      "                        A[A.size() - i - 1] -= res.back() * b.a[b.a.size() - i - 1];",
      "                    }",
      "                }",
      "                A.pop_back();",
      "            }",
      "            std::reverse(begin(res), end(res));",
      "            return {res, A};",
      "        }",
      "        ",
      "        pair<poly, poly> divmod(const poly &b) const { // returns quotiend and remainder of a mod b",
      "            if(deg() < b.deg()) {",
      "                return {poly{0}, *this};",
      "            }",
      "            int d = deg() - b.deg();",
      "            if(min(d, b.deg()) < magic) {",
      "                return divmod_slow(b);",
      "            }",
      "            poly D = (reverse(d + 1) * b.reverse(d + 1).inv(d + 1)).mod_xk(d + 1).reverse(d + 1, 1);",
      "            return {D, *this - D * b};",
      "        }",
      "        ",
      "        poly operator / (const poly &t) const {return divmod(t).first;}",
      "        poly operator % (const poly &t) const {return divmod(t).second;}",
      "        poly operator /= (const poly &t) {return *this = divmod(t).first;}",
      "        poly operator %= (const poly &t) {return *this = divmod(t).second;}",
      "        poly operator *= (const T &x) {",
      "            for(auto &it: a) {",
      "                it *= x;",
      "            }",
      "            normalize();",
      "            return *this;",
      "        }",
      "        poly operator /= (const T &x) {",
      "            for(auto &it: a) {",
      "                it /= x;",
      "            }",
      "            normalize();",
      "            return *this;",
      "        }",
      "        poly operator * (const T &x) const {return poly(*this) *= x;}",
      "        poly operator / (const T &x) const {return poly(*this) /= x;}",
      "        ",
      "        void print() const {",
      "            for(auto it: a) {",
      "                cout << it << ' ';",
      "            }",
      "            cout << endl;",
      "        }",
      "        T eval(T x) const { // evaluates in single point x",
      "            T res(0);",
      "            for(int i = int(a.size()) - 1; i >= 0; i--) {",
      "                res *= x;",
      "                res += a[i];",
      "            }",
      "            return res;",
      "        }",
      "        ",
      "        T& lead() { // leading coefficient",
      "            return a.back();",
      "        }",
      "        int deg() const { // degree",
      "            return a.empty() ? -inf : a.size() - 1;",
      "        }",
      "        bool is_zero() const { // is polynomial zero",
      "            return a.empty();",
      "        }",
      "        T operator [](int idx) const {",
      "            return idx >= (int)a.size() || idx < 0 ? T(0) : a[idx];",
      "        }",
      "        ",
      "        T& coef(size_t idx) { // mutable reference at coefficient",
      "            return a[idx];",
      "        }",
      "        bool operator == (const poly &t) const {return a == t.a;}",
      "        bool operator != (const poly &t) const {return a != t.a;}",
      "        ",
      "        poly deriv() { // calculate derivative",
      "            vector<T> res;",
      "            for(int i = 1; i <= deg(); i++) {",
      "                res.push_back(T(i) * a[i]);",
      "            }",
      "            return res;",
      "        }",
      "        poly integr() { // calculate integral with C = 0",
      "            vector<T> res = {0};",
      "            for(int i = 0; i <= deg(); i++) {",
      "                res.push_back(a[i] / T(i + 1));",
      "            }",
      "            return res;",
      "        }",
      "        size_t leading_xk() const { // Let p(x) = x^k * t(x), return k",
      "            if(is_zero()) {",
      "                return inf;",
      "            }",
      "            int res = 0;",
      "            while(a[res] == T(0)) {",
      "                res++;",
      "            }",
      "            return res;",
      "        }",
      "        poly log(size_t n) { // calculate log p(x) mod x^n",
      "            assert(a[0] == T(1));",
      "            return (deriv().mod_xk(n) * inv(n)).integr().mod_xk(n);",
      "        }",
      "        poly exp(size_t n) { // calculate exp p(x) mod x^n",
      "            if(is_zero()) {",
      "                return T(1);",
      "            }",
      "            assert(a[0] == T(0));",
      "            poly ans = T(1);",
      "            size_t a = 1;",
      "            while(a < n) {",
      "                poly C = ans.log(2 * a).div_xk(a) - substr(a, 2 * a);",
      "                ans -= (ans * C).mod_xk(a).mul_xk(a);",
      "                a *= 2;",
      "            }",
      "            return ans.mod_xk(n);",
      "            ",
      "        }",
      "        poly pow_slow(size_t k, size_t n) { // if k is small",
      "            return k ? k % 2 ? (*this * pow_slow(k - 1, n)).mod_xk(n) : (*this * *this).mod_xk(n).pow_slow(k / 2, n) : T(1);",
      "        }",
      "        poly pow(size_t k, size_t n) { // calculate p^k(n) mod x^n",
      "            if(is_zero()) {",
      "                return *this;",
      "            }",
      "            if(k < magic) {",
      "                return pow_slow(k, n);",
      "            }",
      "            int i = leading_xk();",
      "            T j = a[i];",
      "            poly t = div_xk(i) / j;",
      "            return bpow(j, k) * (t.log(n) * T(k)).exp(n).mul_xk(i * k).mod_xk(n);",
      "        }",
      "        poly mulx(T x) { // component-wise multiplication with x^k",
      "            T cur = 1;",
      "            poly res(*this);",
      "            for(int i = 0; i <= deg(); i++) {",
      "                res.coef(i) *= cur;",
      "                cur *= x;",
      "            }",
      "            return res;",
      "        }",
      "        poly mulx_sq(T x) { // component-wise multiplication with x^{k^2}",
      "            T cur = x;",
      "            T total = 1;",
      "            T xx = x * x;",
      "            poly res(*this);",
      "            for(int i = 0; i <= deg(); i++) {",
      "                res.coef(i) *= total;",
      "                total *= cur;",
      "                cur *= xx;",
      "            }",
      "            return res;",
      "        }",
      "        vector<T> chirpz_even(T z, int n) { // P(1), P(z^2), P(z^4), ..., P(z^2(n-1))",
      "            int m = deg();",
      "            if(is_zero()) {",
      "                return vector<T>(n, 0);",
      "            }",
      "            vector<T> vv(m + n);",
      "            T zi = z.inv();",
      "            T zz = zi * zi;",
      "            T cur = zi;",
      "            T total = 1;",
      "            for(int i = 0; i <= max(n - 1, m); i++) {",
      "                if(i <= m) {vv[m - i] = total;}",
      "                if(i < n) {vv[m + i] = total;}",
      "                total *= cur;",
      "                cur *= zz;",
      "            }",
      "            poly w = (mulx_sq(z) * vv).substr(m, m + n).mulx_sq(z);",
      "            vector<T> res(n);",
      "            for(int i = 0; i < n; i++) {",
      "                res[i] = w[i];",
      "            }",
      "            return res;",
      "        }",
      "        vector<T> chirpz(T z, int n) { // P(1), P(z), P(z^2), ..., P(z^(n-1))",
      "            auto even = chirpz_even(z, (n + 1) / 2);",
      "            auto odd = mulx(z).chirpz_even(z, n / 2);",
      "            vector<T> ans(n);",
      "            for(int i = 0; i < n / 2; i++) {",
      "                ans[2 * i] = even[i];",
      "                ans[2 * i + 1] = odd[i];",
      "            }",
      "            if(n % 2 == 1) {",
      "                ans[n - 1] = even.back();",
      "            }",
      "            return ans;",
      "        }",
      "        template<typename iter>",
      "        vector<T> eval(vector<poly> &tree, int v, iter l, iter r) { // auxiliary evaluation function",
      "            if(r - l == 1) {",
      "                return {eval(*l)};",
      "            } else {",
      "                auto m = l + (r - l) / 2;",
      "                auto A = (*this % tree[2 * v]).eval(tree, 2 * v, l, m);",
      "                auto B = (*this % tree[2 * v + 1]).eval(tree, 2 * v + 1, m, r);",
      "                A.insert(end(A), begin(B), end(B));",
      "                return A;",
      "            }",
      "        }",
      "        vector<T> eval(vector<T> x) { // evaluate polynomial in (x1, ..., xn)",
      "            int n = x.size();",
      "            if(is_zero()) {",
      "                return vector<T>(n, T(0));",
      "            }",
      "            vector<poly> tree(4 * n);",
      "            build(tree, 1, begin(x), end(x));",
      "            return eval(tree, 1, begin(x), end(x));",
      "        }",
      "        template<typename iter>",
      "        poly inter(vector<poly> &tree, int v, iter l, iter r, iter ly, iter ry) { // auxiliary interpolation function",
      "            if(r - l == 1) {",
      "                return {*ly / a[0]};",
      "            } else {",
      "                auto m = l + (r - l) / 2;",
      "                auto my = ly + (ry - ly) / 2;",
      "                auto A = (*this % tree[2 * v]).inter(tree, 2 * v, l, m, ly, my);",
      "                auto B = (*this % tree[2 * v + 1]).inter(tree, 2 * v + 1, m, r, my, ry);",
      "                return A * tree[2 * v + 1] + B * tree[2 * v];",
      "            }",
      "        }",
      "    };",
      "    template<typename T>",
      "    poly<T> operator * (const T& a, const poly<T>& b) {",
      "        return b * a;",
      "    }",
      "    ",
      "    template<typename T>",
      "    poly<T> xk(int k) { // return x^k",
      "        return poly<T>{1}.mul_xk(k);",
      "    }",
      "",
      "    template<typename T>",
      "    T resultant(poly<T> a, poly<T> b) { // computes resultant of a and b",
      "        if(b.is_zero()) {",
      "            return 0;",
      "        } else if(b.deg() == 0) {",
      "            return bpow(b.lead(), a.deg());",
      "        } else {",
      "            int pw = a.deg();",
      "            a %= b;",
      "            pw -= a.deg();",
      "            T mul = bpow(b.lead(), pw) * T((b.deg() & a.deg() & 1) ? -1 : 1);",
      "            T ans = resultant(b, a);",
      "            return ans * mul;",
      "        }",
      "    }",
      "    template<typename iter>",
      "    poly<typename iter::value_type> kmul(iter L, iter R) { // computes (x-a1)(x-a2)...(x-an) without building tree",
      "        if(R - L == 1) {",
      "            return vector<typename iter::value_type>{-*L, 1};",
      "        } else {",
      "            iter M = L + (R - L) / 2;",
      "            return kmul(L, M) * kmul(M, R);",
      "        }",
      "    }",
      "    template<typename T, typename iter>",
      "    poly<T> build(vector<poly<T>> &res, int v, iter L, iter R) { // builds evaluation tree for (x-a1)(x-a2)...(x-an)",
      "        if(R - L == 1) {",
      "            return res[v] = vector<T>{-*L, 1};",
      "        } else {",
      "            iter M = L + (R - L) / 2;",
      "            return res[v] = build(res, 2 * v, L, M) * build(res, 2 * v + 1, M, R);",
      "        }",
      "    }",
      "    template<typename T>",
      "    poly<T> inter(vector<T> x, vector<T> y) { // interpolates minimum polynomial from (xi, yi) pairs",
      "        int n = x.size();",
      "        vector<poly<T>> tree(4 * n);",
      "        return build(tree, 1, begin(x), end(x)).deriv().inter(tree, 1, begin(x), end(x), begin(y), end(y));",
      "    }",
      "};",
      "",
      "using namespace algebra;",
      "",
      "const int MOD = 1e9 + 7;",
      "typedef modular<MOD> base;",
      "typedef poly<ll> polyn;",
      ""
    ],
    "description": "FFT"
  },
  "Roots to polynomial": {
    "prefix": "roots to poly",
    "body": [
      "vector<ll> vietaFormula(vector<ll> roots)",
      "{",
      "    int n = sz(roots);",
      "    vector<ll> coeff(n+1, 0);",
      "",
      "    coeff[n] = 1;",
      "",
      "    for (int i = 1; i <= n; i++) {",
      "        for (int j = n - i - 1; j < n; j++) {",
      "            coeff[j] = coeff[j] + (-1) * roots[i - 1] * coeff[j + 1];",
      "        }",
      "    }",
      "",
      "    return coeff;",
      "}",
      ""
    ],
    "description": "Roots to polynomial"
  },

////////////// DATA STRUCTURES ///////////////

  "Segment tree with lazy propogation": {
    "prefix": "segment tree",
    "body": [
      "",
      "// check maximum N for segment tree",
      "// check whether it is 1-indexed or 0-indexed",
      "#define SEG${1}_T      int",
      "#define SEG${1}_MAXN  (sint)3e5",
      "",
      "SEG${1}_T seg${1}[SEG${1}_MAXN << 2];",
      "int lazy${1}[SEG${1}_MAXN << 2];",
      "",
      "",
      "struct SegmentTree${1}",
      "{",
      "",
      "private:",
      "    vector<SEG${1}_T> &a;",
      "    int s = 0, e;",
      "    SEG${1}_T d, ans;",
      "",
      "",
      "public:",
      "    SegmentTree${1}(int start, int end, int default_ans, vector<SEG${1}_T> &leaves)",
      "    :a(leaves)",
      "    {",
      "        s = start;",
      "        e = end;",
      "        d = default_ans;",
      "        build(1, s, e);",
      "    }",
      "",
      "    SEG${1}_T query(int l, int r)",
      "    {",
      "        ans = query(1, s, e, l, r);",
      "        return ans;",
      "    }",
      "",
      "    void update(int l, int r, int x)",
      "    {",
      "        update(1, s, e, l, r, x);",
      "    }",
      "    ",
      "",
      "private: ",
      "",
      "    // EDIT THESE FUNCTIONS",
      "    SEG${1}_T combine(SEG${1}_T a, SEG${1}_T b)",
      "    {",
      "        return max(a, b);",
      "    }",
      "",
      "    void dolazy(int v)",
      "    {",
      "        int l = lc(v), r = rc(v);",
      "    }",
      "",
      "    void update(int v,int tl,int tr,int l,int r,int x)",
      "    {",
      "        if(l > r) return;",
      "        if(tl == l && tr == r)",
      "        {",
      "",
      "            return;",
      "        }",
      "        dolazy(v);",
      "        update(lc(v),tl,tm,l,min(r,tm),x);",
      "        update(rc(v),tm+1,tr,max(l,tm+1),r,x);",
      "        combine(v);",
      "    }",
      "",
      "",
      "",
      "    void combine(int v)",
      "    {",
      "        int l = lc(v), r = rc(v);",
      "        seg${1}[v] = combine(seg${1}[l], seg${1}[r]);",
      "    }",
      "",
      "    void build(int v,int tl,int tr)",
      "    {",
      "        if(tl == tr)",
      "        {",
      "            seg${1}[v] = a[tl];",
      "            return;",
      "        }",
      "        dolazy(v);",
      "        build(lc(v),tl,tm);",
      "        build(rc(v),tm+1,tr);",
      "        combine(v);",
      "    }",
      "",
      "",
      "    SEG${1}_T query(int v,int tl,int tr,int l,int r)",
      "    {",
      "        if(l > r) return d;",
      "        if(tl == l && tr == r)",
      "        {",
      "            ans = seg${1}[v];",
      "            return ans;",
      "        }",
      "        dolazy(v);",
      "        SEG${1}_T ret = combine(query(lc(v),tl,tm,l,min(r,tm)), query(rc(v),tm+1,tr,max(l,tm+1),r));",
      "        combine(v);",
      "        return ret;",
      "    }",
      "",
      "};"
    ],
    "description": "Segment tree with lazy propogation"
  },
  "Segment Tree": {
    "prefix": "Segment Tree",
    "body": [
      "// combine(v), dolazy and value have tl, tr as args",
      "template<typename T, typename U>",
      "class SegmentTree {",
      "",
      "private:",
      "",
      "    T combine(T l, T r) {",
      "        return l+r;           // change here",
      "    }",
      "",
      "    T value(int v, int tl=-1, int tr=-1) {",
      "        if(islazy[v]) {",
      "            return lazy[v];           // change here",
      "        }",
      "",
      "        return seg[v];",
      "    }",
      "",
      "    void dolazy(int v, int tl=-1, int tr=-1) {",
      "        seg[v] = value(v, tl, tr);",
      "",
      "        if(islazy[v]) {",
      "",
      "            lazy[v<<1] = lazy[v];           // change here",
      "            lazy[v<<1|1] = lazy[v];           // change here",
      "",
      "            islazy[v<<1] = islazy[v<<1|1] = true;",
      "",
      "        }",
      "",
      "        islazy[v] = false;",
      "        lazy[v] = dummy;",
      "",
      "    }",
      "",
      "",
      "    void update(int v, int tl, int tr, int l, int r, int val) {",
      "        if(l > r) return;",
      "",
      "        if(tl == l && tr == r) {",
      "            lazy[v] = val;           // change here",
      "            islazy[v] = true;",
      "            return;",
      "        }",
      "",
      "        dolazy(v, tl, tr);",
      "        int tm = (tl+tr)/2;",
      "        update(v<<1, tl, tm, l, min(r, tm), val);",
      "        update(v<<1|1, tm+1, tr, max(l, tm+1), r, val);",
      "        combine(v, tl, tr);",
      "",
      "    }",
      "",
      "",
      "public:",
      "    void update(int l, int r, int val) {",
      "        update(1, 0, n-1, l, r, val);",
      "    }",
      "",
      "    T query(int l, int r) {",
      "        return query(1, 0, n-1, l, r);",
      "    }",
      "",
      "",
      "",
      "private:",
      "    int n;",
      "    U dummy;",
      "    vector<T> seg, data;",
      "    vector<U> lazy;",
      "    vector<bool> islazy;",
      "",
      "",
      "    void combine(int v, int tl=-1, int tr=-1) {",
      "        seg[v] = combine(value(v<<1, tl, tr), value(v<<1|1, tl, tr));",
      "    }",
      "",
      "    T query(int v, int tl, int tr, int l, int r) {",
      "        if(l > r) return dummy;",
      "",
      "        if(tl == l && tr == r) {",
      "            return value(v, tl, tr);",
      "        }",
      "",
      "        dolazy(v, tl, tr);",
      "        int tm = (tl+tr)/2;",
      "        T left = query(v<<1, tl, tm, l, min(r, tm));",
      "        T right = query(v<<1|1, tm+1, tr, max(l, tm+1), r);",
      "        combine(v, tl, tr);",
      "",
      "        return combine(left, right);",
      "    }",
      "",
      "",
      "    void build(int v, int tl, int tr) {",
      "",
      "        if(tl == tr) {",
      "            seg[v] = data[tl];",
      "            return;",
      "        }",
      "",
      "        int tm = (tl+tr)/2;",
      "",
      "        build(v<<1, tl, tm);",
      "        build(v<<1|1, tm+1, tr);",
      "",
      "        combine(v, tl, tr);",
      "",
      "    }",
      "",
      "public:",
      "    SegmentTree(int n, U initialize=0) {",
      "        this->n = n;",
      "        seg.resize(n*4);",
      "        lazy.assign(n*4, initialize);",
      "        islazy.assign(n*4, false);",
      "",
      "        dummy = initialize;",
      "",
      "    }",
      "",
      "    SegmentTree(int n, vector<T> data, U initialize=0): SegmentTree(n, initialize) {",
      "        this->data = data;",
      "",
      "        build(1, 0, n-1);",
      "    }",
      "",
      "};",
      ""
    ],
    "description": "Segment Tree"
  },
  "Fenwick Tree": {
    "prefix": "Fenwick Tree",
    "body": [
      "// ONLY TO BE USED FOR REVERSIBLE FUNCTIONS",
      "struct FenwickTree {",
      "    vector<long long> bit;",
      "    int n;",
      "",
      "    FenwickTree(int n) {",
      "        this->n = n;",
      "        bit.assign(n, 0);",
      "    }",
      "",
      "    FenwickTree(vector<long long> a) : FenwickTree(a.size()) {",
      "        for (size_t i = 0; i < a.size(); i++)",
      "            add(i, a[i]);",
      "    }",
      "",
      "    long long sum(int r) {",
      "        long long ret = 0;",
      "        for (; r >= 0; r = (r & (r + 1)) - 1)",
      "            ret += bit[r];",
      "        return ret;",
      "    }",
      "",
      "    long long sum(int l, int r) {",
      "        return sum(r) - sum(l - 1);",
      "    }",
      "",
      "    void add(int idx, long long delta) {",
      "        for (; idx < n; idx = idx | (idx + 1))",
      "            bit[idx] += delta;",
      "    }",
      "};",
      ""
    ],
    "description": "Fenwick Tree"
  },
  "Min stack Queue": {
    "prefix": "min stack/queue",
    "body": [
      "class MinStack {",
      "public:",
      " ",
      "    stack<int> dataStack;",
      "    stack<int> minStack;",
      "    /** initialize your data structure here. */",
      "    MinStack() {",
      "    }",
      "    ",
      "    void push(int val) {",
      "        dataStack.push(val);",
      "        if(minStack.empty())",
      "        {",
      "            minStack.push(val);",
      "        }",
      "        else minStack.push(min(val, minStack.top()));",
      "    }",
      "    ",
      "    void pop() {",
      "        if(!dataStack.empty()){",
      "            minStack.pop();",
      "            dataStack.pop();",
      "        }",
      "    }",
      "    ",
      "    int top() {",
      "        return dataStack.top();",
      "    }",
      "    ",
      "    int getMin() {",
      "        return minStack.top();",
      "    }",
      "};",
      "",
      "",
      "struct Minqueue {",
      "",
      "    stack<pair<int, int>> s1, s2;",
      "",
      "    int getMin() {",
      "        int minimum;",
      "        if (s1.empty() || s2.empty()) ",
      "            minimum = s1.empty() ? s2.top().second : s1.top().second;",
      "        else",
      "            minimum = min(s1.top().second, s2.top().second);",
      "",
      "        return minimum;",
      "    }",
      "",
      "    void push(int new_element) {",
      "",
      "        int minimum = s1.empty() ? new_element : min(new_element, s1.top().second);",
      "        s1.push({new_element, minimum});",
      "",
      "    }",
      "",
      "    void pop() {",
      "        if (s2.empty()) {",
      "            while (!s1.empty()) {",
      "                int element = s1.top().first;",
      "                s1.pop();",
      "                int minimum = s2.empty() ? element : min(element, s2.top().second);",
      "                s2.push({element, minimum});",
      "            }",
      "        }",
      "        int remove_element = s2.top().first;",
      "        s2.pop();",
      "    }",
      "",
      "};",
      "",
      ""
    ],
    "description": ""
  },

  "Disjoint set union": {
    "prefix": "DSU",
    "body": [
      "",
      "// 0 BASED INDEXING",
      "${1}// template<typename T>",
      "class dsu",
      "{",
      "    public:",
      "    int n, groups;",
      "    vector<int> parent;",
      "    vector<int> size;",
      "    ${1}// vector<T> data;",
      "    dsu(int n)",
      "    {",
      "        this->n = n;",
      "        parent.resize(n);",
      "        for(int i=0;i<n;i++)",
      "            parent[i] = i;",
      "        size.assign(n, 1);",
      "        groups = n;",
      "    }",
      "",
      "    ${1}// dsu(vector<T> &a) : dsu(a.size()){this->data = a;}",
      "",
      "",
      "    int root(int u)",
      "    {",
      "        if(parent[u] == u)",
      "            return u;",
      "        return parent[u] = root(parent[u]);",
      "    }",
      "",
      "    void q_union(int u, int v)",
      "    {",
      "        int a = root(u);",
      "        int b = root(v);",
      "        if(a != b)",
      "        {",
      "            if(size[a] > size[b])",
      "                swap(a, b);",
      "            parent[a] = b;",
      "            size[b] += size[a];",
      "            // data[b] = {col, max(data[b].second, data[a].second)};",
      "            groups--;",
      "        }",
      "    }",
      "",
      "    bool isconnected(int u, int v)",
      "    {",
      "        return root(u) == root(v);",
      "    }",
      "};",
      "",
      ""
    ],
    "description": "Disjoint set union"
  },

////////////// STRINGS ///////////////////

  "Suffix Array": {
    "prefix": "suffix array",
    "body": [
      "",
      "vector<int> sort_cyclic_shifts(string const& s) {",
      "    int n = s.size();",
      "    const int alphabet = 256;",
      "    vector<int> p(n), c(n), cnt(max(alphabet, n), 0);",
      "    for (int i = 0; i < n; i++)",
      "        cnt[s[i]]++;",
      "    for (int i = 1; i < alphabet; i++)",
      "        cnt[i] += cnt[i-1];",
      "    for (int i = 0; i < n; i++)",
      "        p[--cnt[s[i]]] = i;",
      "    c[p[0]] = 0;",
      "    int classes = 1;",
      "    for (int i = 1; i < n; i++) {",
      "        if (s[p[i]] != s[p[i-1]])",
      "            classes++;",
      "        c[p[i]] = classes - 1;",
      "    }",
      "    vector<int> pn(n), cn(n);",
      "    for (int h = 0; (1 << h) < n; ++h) {",
      "        for (int i = 0; i < n; i++) {",
      "            pn[i] = p[i] - (1 << h);",
      "            if (pn[i] < 0)",
      "                pn[i] += n;",
      "        }",
      "        fill(cnt.begin(), cnt.begin() + classes, 0);",
      "        for (int i = 0; i < n; i++)",
      "            cnt[c[pn[i]]]++;",
      "        for (int i = 1; i < classes; i++)",
      "            cnt[i] += cnt[i-1];",
      "        for (int i = n-1; i >= 0; i--)",
      "            p[--cnt[c[pn[i]]]] = pn[i];",
      "        cn[p[0]] = 0;",
      "        classes = 1;",
      "        for (int i = 1; i < n; i++) {",
      "            pair<int, int> cur = {c[p[i]], c[(p[i] + (1 << h)) % n]};",
      "            pair<int, int> prev = {c[p[i-1]], c[(p[i-1] + (1 << h)) % n]};",
      "            if (cur != prev)",
      "                ++classes;",
      "            cn[p[i]] = classes - 1;",
      "        }",
      "        c.swap(cn);",
      "    }",
      "    return p;",
      "}",
      "",
      "",
      "vector<int> suffix_array_construction(string s) {",
      "    s += \"$\";",
      "    vector<int> sorted_shifts = sort_cyclic_shifts(s);",
      "    sorted_shifts.erase(sorted_shifts.begin());",
      "    return sorted_shifts;",
      "}"
    ],
    "description": "Suffix Array"
  },
  "Hashing Template": {
    "prefix": "rolling hash",
    "body": [
      "",
      "#define ROLL_MAX MX",
      "struct Rolling_Hash {",
      "",
      "    int p;",
      "    int MOD;",
      "    ll p_pow[ROLL_MAX];",
      "    ll inv_pow[ROLL_MAX];",
      "",
      "    Rolling_Hash(int p, int MOD)",
      "    :p(p), MOD(MOD) {",
      "        precompute();",
      "    }",
      "",
      "    // **** returns n+1 values ***",
      "    vector<ll> all_hash(string s)",
      "    {",
      "        int n = sz(s);",
      "        vector<ll> ret(n+1);",
      "        ",
      "        for(int i=1;i<=n;i++)",
      "        {",
      "            ret[i] = mod(ret[i-1] + p_pow[i-1]*(s[i-1]-'a'+1), MOD);",
      "        }",
      "",
      "        return ret;",
      "    }",
      "",
      "    ll hash(string s)",
      "    {",
      "        int n = sz(s);",
      "        ll ret = 0;",
      "        for(int i=0;i<n;i++)",
      "            ret = mod(ret + p_pow[i]*(s[i]-'a'+1), MOD);",
      "        return ret;",
      "    }",
      "",
      "private:",
      "    void precompute()",
      "    {",
      "        p_pow[0] = 1, inv_pow[0] = 1;",
      "        for(int i=1;i<ROLL_MAX;i++)",
      "        {",
      "            p_pow[i] = mod(p_pow[i-1]*p, MOD);",
      "            inv_pow[i] = mod_inverse(p_pow[i], MOD);",
      "        }",
      "    }",
      "};",
      ""
    ],
    "description": "Hashing Template"
  },
  "Prefix Function": {
    "prefix": "prefix function",
    "body": [
      "vector<int> prefix_function(string s) {",
      "    int n = (int)s.length();",
      "    vector<int> pi(n);",
      "    for (int i = 1; i < n; i++) {",
      "        int j = pi[i-1];",
      "        while (j > 0 && s[i] != s[j])",
      "            j = pi[j-1];",
      "        if (s[i] == s[j])",
      "            j++;",
      "        pi[i] = j;",
      "    }",
      "    return pi;",
      "}",
      ""
    ],
    "description": "Prefix Function"
  },
  

///////////////////////// GRAPH ////////////////////////////

  "Graph not sure": {
    "prefix": "graph",
    "body": [
      "template <typename T> struct edge {",
      "    int from, to;",
      "    T cost;",
      "    int id;",
      "    edge(int to, T cost) : from(-1), to(to), cost(cost) {}",
      "    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}",
      "    edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}",
      "    edge &operator=(const int &x) {",
      "        to = x;",
      "        return *this;",
      "    }",
      "    operator int() const { return to; }",
      "};",
      "template <typename T> using Edges = vector<edge<T>>;",
      "",
      "using Tree = vector<vector<int>>;",
      "using Graph = vector<vector<int>>;",
      "template <class T> using Wgraph = vector<vector<edge<T>>>;",
      "Graph getG(int n, int m = -1, bool directed = false, int margin = 1) {",
      "    Tree res(n);",
      "    if(m == -1) m = n - 1;",
      "    while(m--) {",
      "        int a, b;",
      "        cin >> a >> b;",
      "        a -= margin, b -= margin;",
      "        res[a].emplace_back(b);",
      "        if(!directed) res[b].emplace_back(a);",
      "    }",
      "    return move(res);",
      "}",
      "",
      "template <class T> Wgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1) {",
      "    Wgraph<T> res(n);",
      "    if(m == -1) m = n - 1;",
      "    while(m--) {",
      "        int a, b;",
      "        T c;",
      "        cin >> a >> b >> c;",
      "        a -= margin, b -= margin;",
      "        res[a].emplace_back(b, c);",
      "        if(!directed) res[b].emplace_back(a, c);",
      "    }",
      "    return move(res);",
      "}",
      "",
      "",
      "",
      ""
    ],
    "description": "Graph not sure"
  },

  "Dijkstra": {
    "prefix": "Dijkstra",
    "body": [
      "const int INF = 1000000000; // change here",
      "pair<vector<int>, vector<int>> dijkstra(vector<int> s) {",
      "",
      "    vector<int> d, p;",
      "",
      "    d.assign(n, INF);",
      "    p.assign(n, -1);",
      "",
      "    using pii = pair<int, int>;",
      "    priority_queue<pii, vector<pii>, greater<pii>> q;",
      "",
      "    for(int source: s) {",
      "        d[source] = 0;",
      "        q.push({0, source});",
      "    }",
      "",
      "    while(!q.empty()) {",
      "        int v = q.top().second;",
      "        int d_v = q.top().first;",
      "",
      "        q.pop();",
      "",
      "        if(d_v != d[v]) continue;",
      "",
      "        for(auto edge: adj[v]) {",
      "            int to = edge.first;",
      "            int w = edge.second;",
      "",
      "            if(d[v] + w < d[to]) {",
      "                d[to] = d[v] + w;",
      "                p[to] = v;",
      "                q.push({d[to], to});",
      "            }",
      "        }",
      "    }",
      "",
      "    return {d, p};",
      "",
      "}",
      "",
    ],
    "description": "Dijkstra"
  },
  "Bellman-Ford": {
    "prefix": "bellman ford",
    "body": [
      "const int INF = 1000000000; // change here",
      "vector<vector<pair<int, int>>> adj;",
      "",
      "vector<int> neg_cycle;",
      "",
      "pair<vector<int>, vector<int>> bellmanFord(int source)",
      "{",
      "    neg_cycle.clear();",
      "",
      "    vector<int> d(n, INF), p(n, -1);",
      "    d[source] = 0;",
      "    ",
      "    int x;",
      "    for (int i=0; i<n; ++i) {   ",
      "        x = -1;",
      "",
      "        bool any = false;",
      "        for(int i=0;i<n;i++) {",
      "            if(d[i] < INF) { // needs checking",
      "",
      "                for(auto edge: adj[i]) {",
      "                    int to = edge.first, w = edge.second;",
      "",
      "                    if(d[i] + w < d[to]) {",
      "                        d[to] = max(-INF, d[i]+w);",
      "                        p[to] = i;",
      "                        x = to;",
      "",
      "                        any = true;",
      "                    }",
      "                }",
      "                ",
      "            }",
      "        }",
      "",
      "        if(!any) {",
      "            x = -1;",
      "            break;",
      "        }",
      "    }",
      "",
      "    if(x != -1) {",
      "",
      "        int y = x;",
      "        for (int i=0; i<n; ++i)",
      "            y = p[y];",
      "",
      "        for (int cur=y; ; cur=p[cur])",
      "        {",
      "            neg_cycle.push_back (cur);",
      "            if (cur == y && neg_cycle.size() > 1)",
      "                break;",
      "        }",
      "        reverse (neg_cycle.begin(), neg_cycle.end());",
      "    }",
      "",
      "    return {d, p}",
      "}",
      ""
    ],
    "description": "Bellman-Ford"
  },
  "Bellman-Ford SPFA": {
    "prefix": "spfa bellman",
    "body": [
      "const int INF = 1000000000; // change here",
      "vector<vector<pair<int, int>>> adj;",
      "",
      "bool neg_cycle;",
      "",
      "pair<vector<int>, vector<int>> spfa(vector<int> sources) {",
      "",
      "    vector<int> d(n, INF), cnt(n, 0), p(n, -1);",
      "    vector<bool> inqueue(n, false);",
      "    queue<int> q;",
      "",
      "    for(int s: sources) {",
      "        d[s] = 0;",
      "        q.push(s);",
      "        inqueue[s] = true;",
      "    }",
      "",
      "    while (!q.empty()) {",
      "",
      "        int v = q.front();",
      "        q.pop();",
      "        inqueue[v] = false;",
      "",
      "        for (auto edge : adj[v]) {",
      "",
      "            int to = edge.first;",
      "            int len = edge.second;",
      "",
      "            if (d[v] + len < d[to]) {",
      "",
      "                d[to] = max(-INF, d[v] + len);",
      "                p[to] = v;",
      "",
      "                if (!inqueue[to]) {",
      "",
      "                    q.push(to);",
      "                    inqueue[to] = true;",
      "                    cnt[to]++;",
      "",
      "                    if (cnt[to] > n) {",
      "                        neg_cycle = true;",
      "                        return {d, p};  // negative cycle",
      "                    }",
      "                }",
      "",
      "            }",
      "        }",
      "    }",
      "",
      "    neg_cycle = false;",
      "    return {d, p};",
      "}",
      "",
      "",
      ""
    ],
    "description": "Bellman-Ford SPFA"
  },
  "Floyd Warshall": {
    "prefix": "flyod warshall",
    "body": [
      "const int INF = 1000000000;",
      "vector<vector<pair<int, int>>> adj;",
      "",
      "pair<vector<vector<int>>, vector<vector<int>>> flyodWarshall() {",
      "",
      "    vector<vector<int>> d(n, vector<int> (n, INF)), p(n, vector<int> (n, -1));",
      "",
      "    for(int i=0;i<n;i++) {",
      "        d[i][i] = 0;",
      "",
      "        for(auto edge: adj[i]) {",
      "            d[i][edge.first] = edge.second;",
      "        }",
      "    }",
      "",
      "    for (int k = 0; k < n; ++k) {",
      "        for (int i = 0; i < n; ++i) {",
      "            for (int j = 0; j < n; ++j) {",
      "                if (d[i][k] < INF && d[k][j] < INF)",
      "                    d[i][j] = max(-INF, min(d[i][j], d[i][k] + d[k][j])); ",
      "            }",
      "        }",
      "    }",
      "",
      "    for (int i = 0; i < n; ++i) {",
      "        for (int j = 0; j < n; ++j) {",
      "            for (int t = 0; t < n; ++t) {",
      "                if (d[i][t] < INF && d[t][t] < 0 && d[t][j] < INF)",
      "                    d[i][j] = - INF; ",
      "            }",
      "        }",
      "    }",
      "",
      "    return {d, p};",
      "",
      "}",
      "",
      "",
      ""
    ],
    "description": "Floyd Warshall"
  },
  "Path from parent vector": {
    "prefix": "path",
    "body": [
      "vector<int> path(int v, vector<int>& p, int source = -1) {",
      "",
      "    vector<int> path;",
      "",
      "    while(v != source && p[v] != -1) {",
      "        path.push_back(v);",
      "        v = p[v];",
      "    }",
      "",
      "    path.push_back(v);",
      "    reverse(path.begin(), path.end());",
      "",
      "    return path;",
      "}",
      ""
    ],
    "description": "Path from parent vector"
  },

  "Topological sort": {
    "prefix": "topological sort",
    "body": [
      "int n; // number of vertices",
      "vector<vector<int>> adj; // adjacency list of graph",
      "vector<bool> visited;",
      "vector<int> topo_order;",
      "",
      "",
      "// REMEMBER: USES 0 BASED INDEXING",
      "void topo_dfs(int v) {",
      "    visited[v] = true;",
      "    for (int u : adj[v]) {",
      "        if (!visited[u])",
      "            topo_dfs(u);",
      "    }",
      "    topo_order.push_back(v);",
      "}",
      "",
      "void topological_sort() {",
      "    visited.assign(n, false);",
      "    topo_order.clear();",
      "    for (int i = 0; i < n; ++i) {",
      "        if (!visited[i])",
      "            topo_dfs(i);",
      "    }",
      "    reverse(topo_order.begin(), topo_order.end());",
      "}",
      ""
    ],
    "description": "Topological sort"
  },
  "Lowest common ancestor using binary lifting": {
    "prefix": "lca ",
    "body": [
      "// uses 0 indexed labelling",
      "struct LCA {",
      "",
      "    int n, l, root;",
      "    vector<vector<int>> &adj;",
      "",
      "    int timer;",
      "    vector<int> tin, tout;",
      "    vector<vector<int>> up;",
      "    vector<int> height;",
      "",
      "",
      "    LCA(vector<vector<int>> &adj, int root)",
      "    :n(sz(adj)), adj(adj), root(root)",
      "    {",
      "        preprocess();",
      "    }",
      "",
      "    void dfs(int v, int p) {",
      "        if(v != p)",
      "            height[v] = height[p] + 1;",
      "",
      "        tin[v] = ++timer;",
      "        up[v][0] = p;",
      "        for (int i = 1; i <= l; ++i)",
      "            up[v][i] = up[up[v][i-1]][i-1];",
      "",
      "        for (int u : adj[v]) {",
      "            if (u != p)",
      "                dfs(u, v);",
      "        }",
      "",
      "        tout[v] = ++timer;",
      "    }",
      "",
      "    bool is_ancestor(int u, int v) {",
      "        return tin[u] <= tin[v] && tout[u] >= tout[v];",
      "    }",
      "",
      "    int lca(int u, int v) {",
      "        if (is_ancestor(u, v))",
      "            return u;",
      "        if (is_ancestor(v, u))",
      "            return v;",
      "        for (int i = l; i >= 0; --i) {",
      "            if (!is_ancestor(up[u][i], v))",
      "                u = up[u][i];",
      "        }",
      "        return up[u][0];",
      "    }",
      "",
      "    int distance(int u, int v) {",
      "        return height[u] + height[v] - 2*height[lca(u, v)];",
      "    }",
      "",
      "    void preprocess() {",
      "        tin.resize(n);",
      "        tout.resize(n);",
      "        height.resize(n);",
      "",
      "        timer = 0;",
      "        l = ceil(log2(n));",
      "        up.assign(n, vector<int>(l + 1));",
      "        height[root] = 0;",
      "",
      "        dfs(root, root);",
      "    }",
      "",
      "};",
      ""
    ],
    "description": "Lowest common ancestor using binary lifting"
  },
  "Bridges": {
    "prefix": "bridges",
    "body": [
      "int n; // number of nodes",
      "vector<vector<int>> adj; // adjacency list of graph",
      "",
      "set<pair<int, int>> bridges;",
      "vector<bool> visited;",
      "vector<int> tin, low;",
      "int timer;",
      "",
      "void bridge_dfs(int v, int p = -1) {",
      "    visited[v] = true;",
      "    tin[v] = low[v] = timer++;",
      "    for (int to : adj[v]) {",
      "        if (to == p) continue;",
      "        if (visited[to]) {",
      "            low[v] = min(low[v], tin[to]);",
      "        } else {",
      "            bridge_dfs(to, v);",
      "            low[v] = min(low[v], low[to]);",
      "            if (low[to] > tin[v])",
      "                bridges.insert({ min(to, v), max(to, v) });",
      "        }",
      "    }",
      "}",
      "",
      "void find_bridges() {",
      "    timer = 0;",
      "    bridges.clear();",
      "    visited.assign(n, false);",
      "    tin.assign(n, -1);",
      "    low.assign(n, -1);",
      "    for (int i = 0; i < n; ++i) {",
      "        if (!visited[i])",
      "            bridge_dfs(i);",
      "    }",
      "}",
      ""
    ],
    "description": "Bridges"
  },
  "Articulate points": {
    "prefix": "articulate",
    "body": [
      "int n; // number of nodes",
      "vector<vector<int>> adj; // adjacency list of graph",
      "",
      "vector<bool> visited;",
      "vector<int> tin, low;",
      "set<int> arti;",
      "int timer;",
      "",
      "void arti_dfs(int v, int p = -1) {",
      "    visited[v] = true;",
      "    tin[v] = low[v] = timer++;",
      "    int children=0;",
      "    for (int to : adj[v]) {",
      "        if (to == p) continue;",
      "        if (visited[to]) {",
      "            low[v] = min(low[v], tin[to]);",
      "        } else {",
      "            arti_dfs(to, v);",
      "            low[v] = min(low[v], low[to]);",
      "            if (low[to] >= tin[v] && p!=-1)",
      "                arti.insert(v);",
      "            ++children;",
      "        }",
      "    }",
      "    if(p == -1 && children > 1)",
      "        arti.insert(v);",
      "}",
      "",
      "void find_cutpoints() {",
      "    timer = 0;",
      "    arti.clear();",
      "    visited.assign(n, false);",
      "    tin.assign(n, -1);",
      "    low.assign(n, -1);",
      "    for (int i = 0; i < n; ++i) {",
      "        if (!visited[i])",
      "            arti_dfs (i);",
      "    }",
      "}",
      ""
    ],
    "description": "Articulate points"
  },
  "Strongly Connected Components": {
    "prefix": "scc",
    "body": [
      "int nscc;",
      "vector<vector<int>> r_adj;",
      "vector<vector<int>> component;",
      "vector<int> comp;",
      "",
      "// import topological ",
      "void scc_dfs(int v)",
      "{",
      "    visited[v] = true;",
      "    component.back().push_back(v);",
      "    comp[v] = sz(component)-1;",
      "    for(int u: r_adj[v])",
      "        if(!visited[u])",
      "            scc_dfs(u);",
      "}",
      "",
      "",
      "void scc()",
      "{",
      "    component.clear();",
      "    comp.assign(n, -1);",
      "",
      "    r_adj.clear();",
      "    r_adj.resize(n);",
      "    for(int i=0;i<n;i++)",
      "        for(auto j: adj[i])",
      "            r_adj[j].push_back(i);",
      "",
      "    topological_sort();",
      "    visited.assign(n, false);",
      "    for (int i: topo_order) {",
      "        if (!visited[i])",
      "            component.push_back({}), scc_dfs(i);",
      "    }",
      "    nscc = sz(component);",
      "}",
      ""
    ],
    "description": "Strongly Connected Components"
  },
  "Connected Components": {
    "prefix": "cc",
    "body": [
      "vector<vector<int>> components;",
      "vector<bool> visited;",
      "",
      "",
      "void cc_dfs(int u) {",
      "    visited[u] = true;",
      "    components.back().push_back(u);",
      "",
      "    for(int v: adj[u]) {",
      "        if(!visited[v]) {",
      "            cc_dfs(v);",
      "        }",
      "    }",
      "}",
      "",
      "void cc() {",
      "",
      "    components.clear();",
      "    visited.assign(n, false);",
      "",
      "    for(int i=0;i<n;i++) {",
      "        if(!visited[i]) {",
      "            components.push_back({});",
      "            cc_dfs(i);",
      "        }",
      "    }",
      "}",
      ""
    ],
    "description": "Connected Components"
  },
  "2 sat": {
    "prefix": "2 sat",
    "body": [
      "bool satis = false;",
      "vector<bool> assignment;",
      "",
      "// import scc",
      "void sat()",
      "{",
      "    scc();",
      "",
      "    satis = false;",
      "    assignment.assign(n/2, false);",
      "    for(int i=0;i<n;i+=2)",
      "    {",
      "        if(comp[i] == comp[i+1])",
      "            return;",
      "        assignment[i/2] = comp[i] > comp[i+1];",
      "    }",
      "    satis = true;",
      "}",
      ""
    ],
    "description": "2 sat"
  },
  "Condensed Graph": {
    "prefix": "condensed graph",
    "body": [
      "vector<vector<int>> cnd_adj, r_cnd_adj;",
      "",
      "// import strongly cc",
      "void condensed_graph(bool have_cc = false)",
      "{",
      "    if(!have_cc)",
      "        scc();",
      "",
      "    cnd_adj.clear();",
      "    cnd_adj.resize(nscc);",
      "    for(int i=0;i<n;i++) {",
      "        for(auto j: adj[i]) {",
      "            if(comp[i] != comp[j])",
      "                cnd_adj[comp[i]].push_back(comp[j]);",
      "        }",
      "    }",
      "",
      "    for(int i=0;i<nscc;i++)",
      "        UNIQUE(cnd_adj[i]);",
      "",
      "    r_cnd_adj.clear();",
      "    r_cnd_adj.resize(nscc);",
      "",
      "    for(int i=0;i<nscc;i++)",
      "        for(int j: cnd_adj[i])",
      "            r_cnd_adj[j].push_back(i);",
      "    ",
      "}",
      ""
    ],
    "description": "Condensed Graph"
  },
  "DAG2SCC converts dag to scc": {
    "prefix": "dag to scc",
    "body": [
      "struct DAG2SCC",
      "{",
      "    int n;",
      "    vector<vector<int>> &adj, &r_adj;",
      "    vector<pair<int, int>> add_e;",
      "",
      "    DAG2SCC(vector<vector<int>> &adj, vector<vector<int>> &r_adj)",
      "    :adj(adj), r_adj(r_adj), n(sz(adj)){",
      "        DAG2scc();",
      "    }",
      "",
      "    vector<int> visited;",
      "    int DAG_dfs(int v)",
      "    {",
      "        visited[v] = true;",
      "        for(int u: adj[v])",
      "        {",
      "            if(!visited[u]) {",
      "                if(sz(adj[u]) == 0) {",
      "                    visited[u] = true;",
      "                    return u;",
      "                }",
      "                int p = DAG_dfs(u);",
      "                if(p != -1)",
      "                    return p;",
      "            }",
      "        }",
      "        return -1;",
      "    }",
      "",
      "",
      "    void DAG2scc()",
      "    {",
      "        if(n == 1)",
      "            return;",
      "        vector<int> both, source, sink;",
      "        set<int> s_sink;",
      "        for(int i=0;i<n;i++)",
      "        {",
      "            if(sz(adj[i]) == 0 && sz(r_adj[i]) == 0)",
      "                both.push_back(i);",
      "            else if(sz(adj[i]) == 0)",
      "                sink.push_back(i), s_sink.insert(i);",
      "            else if(sz(r_adj[i]) == 0)",
      "                source.push_back(i);",
      "        }",
      "",
      "        // get rid of isolated vertices",
      "        for(int i=1;i<sz(both);i++)",
      "            add_e.push_back({both[i-1], both[i]}), adj[both[i-1]].push_back(both[i]), r_adj[both[i]].push_back(both[i-1]);",
      "        ",
      "        if(!both.empty()) {",
      "            if(!source.empty()) {",
      "                add_e.push_back({both.back(), source[0]}), adj[both.back()].push_back(source[0]), r_adj[source[0]].push_back(both.back());",
      "                source[0] = both[0];",
      "            }",
      "            else {",
      "                source.push_back(both[0]);",
      "                sink.push_back(both.back());",
      "                s_sink.insert(both.back());",
      "            }",
      "        }",
      "",
      "",
      "        // maximal matching",
      "        visited.resize(sz(adj));",
      "",
      "        vector<int> rem_source, rem_sink;",
      "        vector<pair<int, int>> ss_match;",
      "",
      "        for(int i: source)",
      "        {",
      "            if(!visited[i])",
      "            {",
      "                int p = DAG_dfs(i);",
      "                if(p!=-1)",
      "                    ss_match.push_back({i, p}), s_sink.erase(p);",
      "                else",
      "                    rem_source.push_back(i);",
      "            }",
      "        }",
      "",
      "        for(int i: s_sink)",
      "            rem_sink.push_back(i);",
      "        ",
      "        int k = sz(ss_match);",
      "        for(int i=0;i<k;i++)",
      "            add_e.push_back({ss_match[i].second, ss_match[(i+1)%k].first});",
      "",
      "        ",
      "        // remaining match",
      "        k = min(sz(rem_source), sz(rem_sink));",
      "        for(int i=0;i<k;i++)",
      "            add_e.push_back({rem_sink[i], rem_source[i]});",
      "",
      "        // extra matching",
      "        if(sz(rem_source) > sz(rem_sink)) {",
      "            for(int i=k;i<sz(rem_source);i++)",
      "                add_e.push_back({sink[0], rem_source[i]});",
      "        }",
      "        else {",
      "            for(int i=k;i<sz(rem_sink);i++)",
      "                add_e.push_back({rem_sink[i], source[0]});",
      "        }",
      "",
      "    }",
      "",
      "};",
      ""
    ],
    "description": "DAG2SCC converts dag to scc"
  },


  "Bipartitie Matching": {
        "prefix": "biparte matching hoff",
        "body": [
          "",
          "bool dfs(int a, int layer, const vector<vector <int>>& g, vector <int>& btoa, vector <int>& A, vector <int>& B) {",
          "    if (A[a] != layer) return 0;",
          "    A[a] = -1;",
          "    for (auto &b : g[a]) if (B[b] == layer + 1) {",
          "        B[b] = -1;",
          "        if (btoa[b] == -1 || dfs(btoa[b], layer+2, g, btoa, A, B))",
          "            return btoa[b] = a, 1;",
          "    }",
          "    return 0;",
          "}",
          "",
          "int hopcroftKarp(const vector<vector <int>>& g, vector <int>& btoa) {",
          "    int res = 0;",
          "    vector <int> A(g.size()), B(btoa.size()), cur, next;",
          "    for (;;) {",
          "        fill(all(A), 0);",
          "        fill(all(B), -1);",
          "        /// Find the starting nodes for BFS (i.e. layer 0).",
          "        cur.clear();",
          "        for (auto a : btoa) if(a != -1) A[a] = -1;",
          "        for (int a=0; a<sz(g); a++) if(A[a] == 0) cur.push_back(a);",
          "        /// Find all layers using bfs.",
          "        for (int lay = 1;; lay += 2) {",
          "            bool islast = 0;",
          "            next.clear();",
          "            for (auto a : cur) for (auto b : g[a]) {",
          "                if (btoa[b] == -1) {",
          "                    B[b] = lay;",
          "                    islast = 1;",
          "                }",
          "                else if (btoa[b] != a && B[b] == -1) {",
          "                    B[b] = lay;",
          "                    next.push_back(btoa[b]);",
          "                }",
          "            }",
          "            if (islast) break;",
          "            if (next.empty()) return res;",
          "            for(auto a:next) A[a] = lay+1;",
          "            cur.swap(next);",
          "        }",
          "        /// Use DFS to scan for augmenting paths.",
          "        for (int a=0; a<sz(g); a++) {",
          "            if(dfs(a, 0, g, btoa, A, B))",
          "                ++res;",
          "        }",
          "    }",
          "}"
        ],
        "description": ""
  },
  "Dinic's Algo for max flow": {
        "prefix": "Dinic max flow",
        "body": [
          "",
          "struct FlowEdge {",
          "    int v, u;",
          "    long long cap, flow = 0;",
          "    FlowEdge(int v, int u, long long cap) : v(v), u(u), cap(cap) {}",
          "};",
          "",
          "struct Dinic {",
          "    const long long flow_inf = 1e18;",
          "    vector<FlowEdge> edges;",
          "    vector<vector<int>> adj;",
          "    int n, m = 0;",
          "    int s, t;",
          "    vector<int> level, ptr;",
          "    queue<int> q;",
          "",
          "    Dinic(int n, int s, int t) : n(n), s(s), t(t) {",
          "        adj.resize(n);",
          "        level.resize(n);",
          "        ptr.resize(n);",
          "    }",
          "",
          "    void add_edge(int v, int u, long long cap) {",
          "        edges.emplace_back(v, u, cap);",
          "        edges.emplace_back(u, v, 0);",
          "        adj[v].push_back(m);",
          "        adj[u].push_back(m + 1);",
          "        m += 2;",
          "    }",
          "",
          "    bool bfs() {",
          "        while (!q.empty()) {",
          "            int v = q.front();",
          "            q.pop();",
          "            for (int id : adj[v]) {",
          "                if (edges[id].cap - edges[id].flow < 1)",
          "                    continue;",
          "                if (level[edges[id].u] != -1)",
          "                    continue;",
          "                level[edges[id].u] = level[v] + 1;",
          "                q.push(edges[id].u);",
          "            }",
          "        }",
          "        return level[t] != -1;",
          "    }",
          "",
          "    long long dfs(int v, long long pushed) {",
          "        if (pushed == 0)",
          "            return 0;",
          "        if (v == t)",
          "            return pushed;",
          "        for (int& cid = ptr[v]; cid < (int)adj[v].size(); cid++) {",
          "            int id = adj[v][cid];",
          "            int u = edges[id].u;",
          "            if (level[v] + 1 != level[u] || edges[id].cap - edges[id].flow < 1)",
          "                continue;",
          "            long long tr = dfs(u, min(pushed, edges[id].cap - edges[id].flow));",
          "            if (tr == 0)",
          "                continue;",
          "            edges[id].flow += tr;",
          "            edges[id ^ 1].flow -= tr;",
          "            return tr;",
          "        }",
          "        return 0;",
          "    }",
          "",
          "    long long flow() {",
          "        long long f = 0;",
          "        while (true) {",
          "            fill(level.begin(), level.end(), -1);",
          "            level[s] = 0;",
          "            q.push(s);",
          "            if (!bfs())",
          "                break;",
          "            fill(ptr.begin(), ptr.end(), 0);",
          "            while (long long pushed = dfs(s, flow_inf)) {",
          "                f += pushed;",
          "            }",
          "        }",
          "        return f;",
          "    }",
          "};",
          ""
        ],
        "description": "Dinic's Algo for max flow"
  },
  "Max flow": {
        "prefix": "max flow mcSFlow",
        "body": [
          "",
          "template<typename flow_t = ll, typename cost_t = ll>",
          "struct mcSFlow{",
          "    struct Edge{",
          "        cost_t c;",
          "        flow_t f;",
          "        int to, rev;",
          "        Edge(int _to, cost_t _c, flow_t _f, int _rev):c(_c), f(_f), to(_to), rev(_rev){}",
          "    };",
          "    static constexpr cost_t INFCOST = numeric_limits<cost_t>::max()/2;",
          "    cost_t eps;",
          "    int N, S, T;",
          "    vector<vector<Edge> > G;",
          "    vector<unsigned int> isq, cur;",
          "    vector<flow_t> ex;",
          "    vector<cost_t> h;",
          "    mcSFlow(int _N, int _S, int _T):eps(0), N(_N), S(_S), T(_T), G(_N){}",
          "    int connect(int a, int b, flow_t cap, cost_t cost){",
          "        // assert(cap>=0);",
          "        // assert(a>=0&&a<N&&b>=0&&b<N);",
          "        // assert(a!=b);",
          "        cost*=N;",
          "        eps = max(eps, abs(cost));",
          "        G[a].emplace_back(b, cost, cap, G[b].size());",
          "        Edge ret = G[a].back();",
          "        G[b].emplace_back(a, -cost, 0, G[a].size()-1);",
          "        return (int)G[a].size() - 1;",
          "    }",
          "    void add_flow(Edge& e, flow_t f) {",
          "        Edge &back = G[e.to][e.rev];",
          "        if (!ex[e.to] && f)",
          "            hs[h[e.to]].push_back(e.to);",
          "        e.f -= f; ex[e.to] += f;",
          "        back.f += f; ex[back.to] -= f;",
          "    }",
          "    vector<vector<int> > hs;",
          "    vector<int> co;",
          "    // fast max flow, lowest label version",
          "    flow_t max_flow() {",
          "        ex.assign(N, 0);",
          "        h.assign(N, 0); hs.resize(2*N);",
          "        co.assign(2*N, 0); cur.assign(N, 0);",
          "        h[S] = N;",
          "        ex[T] = 1;",
          "        co[0] = N-1;",
          "        for(auto &e:G[S]) add_flow(e, e.f);",
          "        if(hs[0].size())",
          "            for (int hi = 0;hi>=0;) {",
          "                int u = hs[hi].back();",
          "                hs[hi].pop_back();",
          "                while (ex[u] > 0) { // discharge u",
          "                    if (cur[u] == G[u].size()) {",
          "                        h[u] = 1e9;",
          "                        for(unsigned int i=0;i<G[u].size();++i){",
          "                            auto &e = G[u][i];",
          "                            if (e.f && h[u] > h[e.to]+1){",
          "                                h[u] = h[e.to]+1;",
          "                                cur[u] = i;",
          "                            }",
          "                        }",
          "                        if (++co[h[u]], !--co[hi] && hi < N)",
          "                            for(int i=0;i<N;++i){",
          "                                if (hi < h[i] && h[i] < N){",
          "                                    --co[h[i]];",
          "                                    h[i] = N + 1;",
          "                                }",
          "                            }",
          "                        hi = h[u];",
          "                    } else if (G[u][cur[u]].f && h[u] == h[G[u][cur[u]].to]+1){",
          "                        add_flow(G[u][cur[u]], min(ex[u], G[u][cur[u]].f));",
          "                    } else ++cur[u];",
          "                }",
          "                while (hi>=0 && hs[hi].empty()) --hi;",
          "            }",
          "        return -ex[S];",
          "    }",
          "    // begin min cost flow",
          "    bool look_ahead(int u){",
          "        if(ex[u]) return false;",
          "        cost_t newHeight = h[u]-N*eps;",
          "        for(auto const&e:G[u]){",
          "            if(e.f == 0) continue;",
          "            if(h[u] + e.c - h[e.to] < 0) return false; // outgoing admissible arc",
          "            else newHeight = max(newHeight, h[e.to] - e.c); // try to make arc admissible",
          "        }",
          "        h[u] = newHeight - eps;",
          "        return true;",
          "    }",
          "    void push(Edge &e, flow_t amt){",
          "        if(e.f < amt) amt=e.f;",
          "        e.f-=amt; ex[e.to]+=amt;",
          "        G[e.to][e.rev].f+=amt; ex[G[e.to][e.rev].to]-=amt;",
          "    }",
          "    void relabel(int vertex){",
          "        cost_t newHeight = -INFCOST;",
          "        for(unsigned int i=0;i<G[vertex].size();++i){",
          "            Edge const&e = G[vertex][i];",
          "            if(e.f && newHeight < h[e.to]-e.c){",
          "                newHeight = h[e.to] - e.c;",
          "                cur[vertex] = i;",
          "            }",
          "        }",
          "        h[vertex] = newHeight - eps;",
          "    }",
          "    static constexpr int scale=2;",
          "    template<bool use_look_ahead = true>",
          "    pair<flow_t, cost_t> minCostMaxFlow(){",
          "        cost_t retCost = 0;",
          "        for(int i=0;i<N;++i)",
          "            for(Edge &e:G[i])",
          "                retCost += e.c*(e.f);",
          "        // remove this for circulation",
          "        flow_t retFlow = max_flow();",
          "        h.assign(N, 0); ex.assign(N, 0);",
          "        isq.assign(N, 0); cur.assign(N,0);",
          "        stack<int> q;",
          "        for(;eps;eps>>=scale){",
          "            fill(cur.begin(), cur.end(), 0);",
          "            for(int i=0;i<N;++i)",
          "                for(auto &e:G[i])",
          "                    if(h[i] + e.c - h[e.to] < 0 && e.f)",
          "                        push(e, e.f);",
          "            for(int i=0;i<N;++i){",
          "                if(ex[i]>0){",
          "                    q.push(i);",
          "                    isq[i]=1;",
          "                }",
          "            }",
          "            while(!q.empty()){",
          "                int u=q.top();q.pop();",
          "                isq[u]=0;",
          "                while(ex[u]>0){",
          "                    if(cur[u] == G[u].size())",
          "                        relabel(u);",
          "                    for(unsigned int &i=cur[u], max_i = G[u].size();i<max_i;++i){",
          "                        Edge &e=G[u][i];",
          "                        if(e.f == 0) continue;",
          "                        if(h[u] + e.c - h[e.to] < 0){",
          "                            if(use_look_ahead && look_ahead(e.to)){",
          "                                --i;",
          "                                continue;",
          "                            }",
          "                            push(e, ex[u]);",
          "                            if(isq[e.to]==0){",
          "                                q.push(e.to);",
          "                                isq[e.to]=1;",
          "                            }",
          "                            if(ex[u]==0) break;",
          "                        }",
          "                    }",
          "                }",
          "            }",
          "            if(eps>1 && eps>>scale==0){",
          "                eps = 1<<scale;",
          "            }",
          "        }",
          "        for(int i=0;i<N;++i){",
          "            for(Edge &e:G[i]){",
          "                retCost -= e.c*(e.f);",
          "            }",
          "        }",
          "        return make_pair(retFlow, retCost/2/N);",
          "    }",
          "    flow_t getFlow(Edge const &e){",
          "        return G[e.to][e.rev].f;",
          "    }",
          "};",
          ""
        ],
        "description": ""
  },


  "directed mst": {
        "prefix": "directed mst",
        "body": [
          "",
          "template<class T>",
          "struct graph{",
          "    struct edge{",
          "        int from, to;",
          "        T cost;",
          "    };",
          "    int n;",
          "    vector<edge> edges;",
          "    vector<vector<int>> adj;",
          "    function<bool(int)> ignore; // edge ignoration rule",
          "    graph(int n): n(n), adj(n){ }",
          "    // int link(int u, int v, T w = 1){ // insert an undirected edge",
          "    //   int id = (int)edges.size();",
          "    //   adj[u].push_back(id), adj[v].push_back(id), edges.push_back({u, v, w});",
          "    //   return id;",
          "    //}",
          "    int orient(int u, int v, T w = 1){ // insert a directed edge",
          "        int id = (int)edges.size();",
          "        adj[u].push_back(id), edges.push_back({u, v, w});",
          "        return id;",
          "    }",
          "    // graph transposed() const{ // the transpose of the directed graph",
          "    //   graph res(n);",
          "    //   for(auto &e: edges) res.orient(e.to, e.from, e.cost);",
          "    //   res.ignore = ignore;",
          "    //   return res;",
          "    // }",
          "    int degree(int u){ // the degree (outdegree if directed) of u (without the ignoration rule)",
          "        return (int)adj[u].size();",
          "    }",
          "};",
          "",
          "struct rollback_disjoint_set{",
          "    vector<int> p;",
          "    vector<pair<int, int>> log;",
          "    rollback_disjoint_set(int n): p(n, -1){ }",
          "    bool share(int a, int b){ return root(a) == root(b); }",
          "    int sz(int u){ return -p[root(u)]; }",
          "    int root(int u){ return p[u] < 0 ? u : root(p[u]); } // O(log n)",
          "    bool merge(int u, int v){",
          "        u = root(u), v = root(v);",
          "        if(u == v) return false;",
          "        if(p[u] > p[v]) swap(u, v);",
          "        log.emplace_back(v, p[v]);",
          "        p[u] += p[v], p[v] = u;",
          "        return true;",
          "    }",
          "    int time(){ return (int)log.size(); }",
          "    void reverse_to(int t = 0){",
          "        while((int)log.size() > t){",
          "            auto [v, pv] = log.back(); log.pop_back();",
          "            p[p[v]] -= pv, p[v] = pv;",
          "        }",
          "    }",
          "};",
          "",
          "// Requires graph and rollback_disjoint_set",
          "template<class U, class T>",
          "pair<U, vector<int>> minimum_spanning_arborescence(const graph<T> &g, int src){",
          "    using edge = typename graph<T>::edge;",
          "    struct node{ /// lazy skew heap node",
          "        edge key;",
          "        node *l, *r;",
          "        U delta;",
          "        void prop(){",
          "            key.cost += delta;",
          "            if(l) l->delta += delta;",
          "            if(r) r->delta += delta;",
          "            delta = 0;",
          "        }",
          "        edge top() { prop(); return key; }",
          "    };",
          "    function<node *(node *, node *)> merge = [&](node *a, node *b){",
          "        if(!a || !b) return a ?: b;",
          "        a->prop(), b->prop();",
          "        if(a->key.cost > b->key.cost) swap(a, b);",
          "        swap(a->l, (a->r = merge(b, a->r)));",
          "        return a;",
          "    };",
          "    auto pop = [&](node *&a){",
          "        a->prop(), a = merge(a->l, a->r);",
          "    };",
          "    int n = g.n;",
          "    U cost = {};",
          "    vector<int> pv(n);",
          "    rollback_disjoint_set dsu(n);",
          "    vector<node *> heap(n);",
          "    for(auto e: g.edges) heap[e.to] = merge(heap[e.to], new node{e});",
          "    vector<int> seen(n, -1), path(n);",
          "    seen[src] = src;",
          "    vector<edge> Q(n), in(n, {-1, -1}), comp;",
          "    deque<tuple<int, int, vector<edge>>> cycs;",
          "    for(auto s = 0; s < n; ++ s){",
          "        int u = s, qi = 0, w;",
          "        while(seen[u] < 0){",
          "            if(!heap[u]) return {0, {}};",
          "            edge e = heap[u]->top();",
          "            heap[u]->delta -= e.cost, pop(heap[u]);",
          "            Q[qi] = e, path[qi ++] = u, seen[u] = s;",
          "            cost += e.cost, u = dsu.root(e.from);",
          "            if(seen[u] == s){ // found cycle, contract",
          "                node *cyc = 0;",
          "                int end = qi, time = dsu.time();",
          "                do cyc = merge(cyc, heap[w = path[-- qi]]);",
          "                while(dsu.merge(u, w));",
          "                u = dsu.root(u), heap[u] = cyc, seen[u] = -1;",
          "                cycs.push_front({u, time, {&Q[qi], &Q[end]}});",
          "            }",
          "        }",
          "        for(auto i = 0; i < qi; ++ i) in[dsu.root(Q[i].to)] = Q[i];",
          "    }",
          "    for(auto &[u, t, comp]: cycs){ // restore sol (optional)",
          "        dsu.reverse_to(t);",
          "        edge ine = in[u];",
          "        for(auto &e: comp) in[dsu.root(e.to)] = e;",
          "        in[dsu.root(ine.to)] = ine;",
          "    }",
          "    for(auto i = 0; i < n; ++ i) pv[i] = in[i].from;",
          "    return {cost, pv};",
          "}",
          "",
          "template<class T>",
          "struct graph{",
          "    struct edge{",
          "        int from, to;",
          "        T cost;",
          "    };",
          "    int n;",
          "    vector<edge> edges;",
          "    vector<vector<int>> adj;",
          "    function<bool(int)> ignore; // edge ignoration rule",
          "    graph(int n): n(n), adj(n){ }",
          "    // int link(int u, int v, T w = 1){ // insert an undirected edge",
          "    //   int id = (int)edges.size();",
          "    //   adj[u].push_back(id), adj[v].push_back(id), edges.push_back({u, v, w});",
          "    //   return id;",
          "    // }",
          "    int orient(int u, int v, T w = 1){ // insert a directed edge",
          "        int id = (int)edges.size();",
          "        adj[u].push_back(id), edges.push_back({u, v, w});",
          "        return id;",
          "    }",
          "    // graph transposed() const{ // the transpose of the directed graph",
          "    //   graph res(n);",
          "    //   for(auto &e: edges) res.orient(e.to, e.from, e.cost);",
          "    //   res.ignore = ignore;",
          "    //   return res;",
          "    // }",
          "    int degree(int u){ // the degree (outdegree if directed) of u (without the ignoration rule)",
          "        return (int)adj[u].size();",
          "    }",
          "};",
          "",
          "struct rollback_disjoint_set{",
          "    vector<int> p;",
          "    vector<pair<int, int>> log;",
          "    rollback_disjoint_set(int n): p(n, -1){ }",
          "    bool share(int a, int b){ return root(a) == root(b); }",
          "    int sz(int u){ return -p[root(u)]; }",
          "    int root(int u){ return p[u] < 0 ? u : root(p[u]); } // O(log n)",
          "    bool merge(int u, int v){",
          "        u = root(u), v = root(v);",
          "        if(u == v) return false;",
          "        if(p[u] > p[v]) swap(u, v);",
          "        log.emplace_back(v, p[v]);",
          "        p[u] += p[v], p[v] = u;",
          "        return true;",
          "    }",
          "    int time(){ return (int)log.size(); }",
          "    void reverse_to(int t = 0){",
          "        while((int)log.size() > t){",
          "            auto [v, pv] = log.back(); log.pop_back();",
          "            p[p[v]] -= pv, p[v] = pv;",
          "        }",
          "    }",
          "};",
          "",
          "// Requires graph and rollback_disjoint_set",
          "template<class U, class T>",
          "pair<U, vector<int>> minimum_spanning_arborescence(const graph<T> &g, int src){",
          "    using edge = typename graph<T>::edge;",
          "    struct node{ /// lazy skew heap node",
          "        edge key;",
          "        node *l, *r;",
          "        U delta;",
          "        void prop(){",
          "            key.cost += delta;",
          "            if(l) l->delta += delta;",
          "            if(r) r->delta += delta;",
          "            delta = 0;",
          "        }",
          "        edge top() { prop(); return key; }",
          "    };",
          "    function<node *(node *, node *)> merge = [&](node *a, node *b){",
          "        if(!a || !b) return a ?: b;",
          "        a->prop(), b->prop();",
          "        if(a->key.cost > b->key.cost) swap(a, b);",
          "        swap(a->l, (a->r = merge(b, a->r)));",
          "        return a;",
          "    };",
          "    auto pop = [&](node *&a){",
          "        a->prop(), a = merge(a->l, a->r);",
          "    };",
          "    int n = g.n;",
          "    U cost = {};",
          "    vector<int> pv(n);",
          "    rollback_disjoint_set dsu(n);",
          "    vector<node *> heap(n);",
          "    for(auto e: g.edges) heap[e.to] = merge(heap[e.to], new node{e});",
          "    vector<int> seen(n, -1), path(n);",
          "    seen[src] = src;",
          "    vector<edge> Q(n), in(n, {-1, -1}), comp;",
          "    deque<tuple<int, int, vector<edge>>> cycs;",
          "    for(auto s = 0; s < n; ++ s){",
          "        int u = s, qi = 0, w;",
          "        while(seen[u] < 0){",
          "            if(!heap[u]) return {0, {}};",
          "            edge e = heap[u]->top();",
          "            heap[u]->delta -= e.cost, pop(heap[u]);",
          "            Q[qi] = e, path[qi ++] = u, seen[u] = s;",
          "            cost += e.cost, u = dsu.root(e.from);",
          "            if(seen[u] == s){ // found cycle, contract",
          "                node *cyc = 0;",
          "                int end = qi, time = dsu.time();",
          "                do cyc = merge(cyc, heap[w = path[-- qi]]);",
          "                while(dsu.merge(u, w));",
          "                u = dsu.root(u), heap[u] = cyc, seen[u] = -1;",
          "                cycs.push_front({u, time, {&Q[qi], &Q[end]}});",
          "            }",
          "        }",
          "        for(auto i = 0; i < qi; ++ i) in[dsu.root(Q[i].to)] = Q[i];",
          "    }",
          "    for(auto &[u, t, comp]: cycs){ // restore sol (optional)",
          "        dsu.reverse_to(t);",
          "        edge ine = in[u];",
          "        for(auto &e: comp) in[dsu.root(e.to)] = e;",
          "        in[dsu.root(ine.to)] = ine;",
          "    }",
          "    for(auto i = 0; i < n; ++ i) pv[i] = in[i].from;",
          "    return {cost, pv};",
          "}",
          "",
          "template<class T>",
          "struct graph{",
          "    struct edge{",
          "        int from, to;",
          "        T cost;",
          "    };",
          "    int n;",
          "    vector<edge> edges;",
          "    vector<vector<int>> adj;",
          "    function<bool(int)> ignore; // edge ignoration rule",
          "    graph(int n): n(n), adj(n){ }",
          "    // int link(int u, int v, T w = 1){ // insert an undirected edge",
          "    //   int id = (int)edges.size();",
          "    //   adj[u].push_back(id), adj[v].push_back(id), edges.push_back({u, v, w});",
          "    //   return id;",
          "    // }",
          "    int orient(int u, int v, T w = 1){ // insert a directed edge",
          "        int id = (int)edges.size();",
          "        adj[u].push_back(id), edges.push_back({u, v, w});",
          "        return id;",
          "    }",
          "    // graph transposed() const{ // the transpose of the directed graph",
          "    //   graph res(n);",
          "    //   for(auto &e: edges) res.orient(e.to, e.from, e.cost);",
          "    //   res.ignore = ignore;",
          "    //   return res;",
          "    // }",
          "    int degree(int u){ // the degree (outdegree if directed) of u (without the ignoration rule)",
          "        return (int)adj[u].size();",
          "    }",
          "};",
          "",
          "struct rollback_disjoint_set{",
          "    vector<int> p;",
          "    vector<pair<int, int>> log;",
          "    rollback_disjoint_set(int n): p(n, -1){ }",
          "    bool share(int a, int b){ return root(a) == root(b); }",
          "    int sz(int u){ return -p[root(u)]; }",
          "    int root(int u){ return p[u] < 0 ? u : root(p[u]); } // O(log n)",
          "    bool merge(int u, int v){",
          "        u = root(u), v = root(v);",
          "        if(u == v) return false;",
          "        if(p[u] > p[v]) swap(u, v);",
          "        log.emplace_back(v, p[v]);",
          "        p[u] += p[v], p[v] = u;",
          "        return true;",
          "    }",
          "    int time(){ return (int)log.size(); }",
          "    void reverse_to(int t = 0){",
          "        while((int)log.size() > t){",
          "            auto [v, pv] = log.back(); log.pop_back();",
          "            p[p[v]] -= pv, p[v] = pv;",
          "        }",
          "    }",
          "};",
          "",
          "// Requires graph and rollback_disjoint_set",
          "template<class U, class T>",
          "pair<U, vector<int>> minimum_spanning_arborescence(const graph<T> &g, int src){",
          "    using edge = typename graph<T>::edge;",
          "    struct node{ /// lazy skew heap node",
          "        edge key;",
          "        node *l, *r;",
          "        U delta;",
          "        void prop(){",
          "            key.cost += delta;",
          "            if(l) l->delta += delta;",
          "            if(r) r->delta += delta;",
          "            delta = 0;",
          "        }",
          "        edge top() { prop(); return key; }",
          "    };",
          "    function<node *(node *, node *)> merge = [&](node *a, node *b){",
          "        if(!a || !b) return a ?: b;",
          "        a->prop(), b->prop();",
          "        if(a->key.cost > b->key.cost) swap(a, b);",
          "        swap(a->l, (a->r = merge(b, a->r)));",
          "        return a;",
          "    };",
          "    auto pop = [&](node *&a){",
          "        a->prop(), a = merge(a->l, a->r);",
          "    };",
          "    int n = g.n;",
          "    U cost = {};",
          "    vector<int> pv(n);",
          "    rollback_disjoint_set dsu(n);",
          "    vector<node *> heap(n);",
          "    for(auto e: g.edges) heap[e.to] = merge(heap[e.to], new node{e});",
          "    vector<int> seen(n, -1), path(n);",
          "    seen[src] = src;",
          "    vector<edge> Q(n), in(n, {-1, -1}), comp;",
          "    deque<tuple<int, int, vector<edge>>> cycs;",
          "    for(auto s = 0; s < n; ++ s){",
          "        int u = s, qi = 0, w;",
          "        while(seen[u] < 0){",
          "            if(!heap[u]) return {0, {}};",
          "            edge e = heap[u]->top();",
          "            heap[u]->delta -= e.cost, pop(heap[u]);",
          "            Q[qi] = e, path[qi ++] = u, seen[u] = s;",
          "            cost += e.cost, u = dsu.root(e.from);",
          "            if(seen[u] == s){ // found cycle, contract",
          "                node *cyc = 0;",
          "                int end = qi, time = dsu.time();",
          "                do cyc = merge(cyc, heap[w = path[-- qi]]);",
          "                while(dsu.merge(u, w));",
          "                u = dsu.root(u), heap[u] = cyc, seen[u] = -1;",
          "                cycs.push_front({u, time, {&Q[qi], &Q[end]}});",
          "            }",
          "        }",
          "        for(auto i = 0; i < qi; ++ i) in[dsu.root(Q[i].to)] = Q[i];",
          "    }",
          "    for(auto &[u, t, comp]: cycs){ // restore sol (optional)",
          "        dsu.reverse_to(t);",
          "        edge ine = in[u];",
          "        for(auto &e: comp) in[dsu.root(e.to)] = e;",
          "        in[dsu.root(ine.to)] = ine;",
          "    }",
          "    for(auto i = 0; i < n; ++ i) pv[i] = in[i].from;",
          "    return {cost, pv};",
          "}",
          "",
          "template<class T>",
          "struct graph{",
          "    struct edge{",
          "        int from, to;",
          "        T cost;",
          "    };",
          "    int n;",
          "    vector<edge> edges;",
          "    vector<vector<int>> adj;",
          "    function<bool(int)> ignore; // edge ignoration rule",
          "    graph(int n): n(n), adj(n){ }",
          "    // int link(int u, int v, T w = 1){ // insert an undirected edge",
          "    //   int id = (int)edges.size();",
          "    //   adj[u].push_back(id), adj[v].push_back(id), edges.push_back({u, v, w});",
          "    //   return id;",
          "    // }",
          "    int orient(int u, int v, T w = 1){ // insert a directed edge",
          "        int id = (int)edges.size();",
          "        adj[u].push_back(id), edges.push_back({u, v, w});",
          "        return id;",
          "    }",
          "    // graph transposed() const{ // the transpose of the directed graph",
          "    //   graph res(n);",
          "    //   for(auto &e: edges) res.orient(e.to, e.from, e.cost);",
          "    //   res.ignore = ignore;",
          "    //   return res;",
          "    // }",
          "    int degree(int u){ // the degree (outdegree if directed) of u (without the ignoration rule)",
          "        return (int)adj[u].size();",
          "    }",
          "};",
          "",
          "struct rollback_disjoint_set{",
          "    vector<int> p;",
          "    vector<pair<int, int>> log;",
          "    rollback_disjoint_set(int n): p(n, -1){ }",
          "    bool share(int a, int b){ return root(a) == root(b); }",
          "    int sz(int u){ return -p[root(u)]; }",
          "    int root(int u){ return p[u] < 0 ? u : root(p[u]); } // O(log n)",
          "    bool merge(int u, int v){",
          "        u = root(u), v = root(v);",
          "        if(u == v) return false;",
          "        if(p[u] > p[v]) swap(u, v);",
          "        log.emplace_back(v, p[v]);",
          "        p[u] += p[v], p[v] = u;",
          "        return true;",
          "    }",
          "    int time(){ return (int)log.size(); }",
          "    void reverse_to(int t = 0){",
          "        while((int)log.size() > t){",
          "            auto [v, pv] = log.back(); log.pop_back();",
          "            p[p[v]] -= pv, p[v] = pv;",
          "        }",
          "    }",
          "};",
          "",
          "// Requires graph and rollback_disjoint_set",
          "template<class U, class T>",
          "pair<U, vector<int>> minimum_spanning_arborescence(const graph<T> &g, int src){",
          "    using edge = typename graph<T>::edge;",
          "    struct node{ /// lazy skew heap node",
          "        edge key;",
          "        node *l, *r;",
          "        U delta;",
          "        void prop(){",
          "            key.cost += delta;",
          "            if(l) l->delta += delta;",
          "            if(r) r->delta += delta;",
          "            delta = 0;",
          "        }",
          "        edge top() { prop(); return key; }",
          "    };",
          "    function<node *(node *, node *)> merge = [&](node *a, node *b){",
          "        if(!a || !b) return a ?: b;",
          "        a->prop(), b->prop();",
          "        if(a->key.cost > b->key.cost) swap(a, b);",
          "        swap(a->l, (a->r = merge(b, a->r)));",
          "        return a;",
          "    };",
          "    auto pop = [&](node *&a){",
          "        a->prop(), a = merge(a->l, a->r);",
          "    };",
          "    int n = g.n;",
          "    U cost = {};",
          "    vector<int> pv(n);",
          "    rollback_disjoint_set dsu(n);",
          "    vector<node *> heap(n);",
          "    for(auto e: g.edges) heap[e.to] = merge(heap[e.to], new node{e});",
          "    vector<int> seen(n, -1), path(n);",
          "    seen[src] = src;",
          "    vector<edge> Q(n), in(n, {-1, -1}), comp;",
          "    deque<tuple<int, int, vector<edge>>> cycs;",
          "    for(auto s = 0; s < n; ++ s){",
          "        int u = s, qi = 0, w;",
          "        while(seen[u] < 0){",
          "            if(!heap[u]) return {0, {}};",
          "            edge e = heap[u]->top();",
          "            heap[u]->delta -= e.cost, pop(heap[u]);",
          "            Q[qi] = e, path[qi ++] = u, seen[u] = s;",
          "            cost += e.cost, u = dsu.root(e.from);",
          "            if(seen[u] == s){ // found cycle, contract",
          "                node *cyc = 0;",
          "                int end = qi, time = dsu.time();",
          "                do cyc = merge(cyc, heap[w = path[-- qi]]);",
          "                while(dsu.merge(u, w));",
          "                u = dsu.root(u), heap[u] = cyc, seen[u] = -1;",
          "                cycs.push_front({u, time, {&Q[qi], &Q[end]}});",
          "            }",
          "        }",
          "        for(auto i = 0; i < qi; ++ i) in[dsu.root(Q[i].to)] = Q[i];",
          "    }",
          "    for(auto &[u, t, comp]: cycs){ // restore sol (optional)",
          "        dsu.reverse_to(t);",
          "        edge ine = in[u];",
          "        for(auto &e: comp) in[dsu.root(e.to)] = e;",
          "        in[dsu.root(ine.to)] = ine;",
          "    }",
          "    for(auto i = 0; i < n; ++ i) pv[i] = in[i].from;",
          "    return {cost, pv};",
          "}",
          ""
        ],
        "description": ""
  },


//////////////// GAME THEORY ///////////////////

  "game graph": {
    "prefix": "game graph",
    "body": [
      "",
      "vector<vector<int>> adj_rev;",
      "",
      "vector<bool> winning;",
      "vector<bool> losing;",
      "vector<bool> visited;",
      "vector<int> degree;",
      "",
      "void dfs(int v) {",
      "    visited[v] = true;",
      "    for (int u : adj_rev[v]) {",
      "        if (!visited[u]) {",
      "            if (losing[v])",
      "                winning[u] = true;",
      "            else if (--degree[u] == 0)",
      "                losing[u] = true;",
      "            else",
      "                continue;",
      "            dfs(u);",
      "        }",
      "    }",
      "}",
      "",
      "void game_preprocess(int n)",
      "{",
      "    adj_rev.resize(n);",
      "    winning.resize(n);",
      "    losing.resize(n);",
      "    visited.resize(n);",
      "    degree.resize(n);",
      "}",
      "",
      ""
    ],
    "description": "game graph"
  },
  "calculates mex value": {
    "prefix": "MEX",
    "body": [
      "int MEX(vector<int> &v)",
      "{",
      "    set<int> s(all(v));",
      "    int mex = -1;",
      "    while(s.count(++mex));",
      "    return mex;",
      "}",
      "",
      ""
    ],
    "description": "calculates mex value"
  },



///////////////// BIG INT and RED-BLACK TREE /////////////////////////

  "implements red black tree": {
      "prefix": "rb tree",
      "body": [
        "",
        "template <class Key,class Value>",
        "class rbtree",
        "{",
        "  private:",
        "    class node",
        "    {",
        "      public:",
        "        Key key;",
        "        Value val;",
        "        node *left = NULL , *right = NULL ;",
        "        bool color = true;",
        "        int size = 1;",
        "        int height = 1;",
        "",
        "        node(Key x , Value y)",
        "        :key(x),val(y)",
        "        {}",
        "    };",
        "",
        "    node* root = NULL;",
        "",
        "    inline void sizeupdate(node* h)",
        "    {",
        "      h->size = sz(h->left) + sz(h->right) + 1;",
        "    }",
        "",
        "    inline void heightupdate(node* h)",
        "    {",
        "      h->height = max(ht(h->left),ht(h->right)) + 1;",
        "    }",
        "",
        "    inline bool isred(node* h)",
        "    {",
        "      if(h == NULL) return false;",
        "      return h->color;",
        "    }",
        "",
        "    node* put(node* x,Key k,Value v)",
        "    {",
        "      if(x == NULL) return new node(k,v);",
        "      if(x->key > k) x->left = put(x->left,k,v);",
        "      else if(x->key < k) x->right = put(x->right,k,v);",
        "      else x->val = v;",
        "",
        "      if(isred(x->right) && !isred(x->left)) x = rotateleft(x);",
        "      if(isred(x->left) && isred(x->left->left)) x = rotateright(x);",
        "      if(isred(x->left) && isred(x->right)) x = flipcolor(x);",
        "",
        "      sizeupdate(x);",
        "      heightupdate(x);",
        "      return x;",
        "    }",
        "",
        "    node* get(node *x , Key k)",
        "    {",
        "      while(x != NULL)",
        "      {",
        "        if(k < x->key) x = x->left;",
        "        else if (k > x->key) x = x->right;",
        "        else return x;",
        "      }",
        "      return NULL;",
        "    }",
        "",
        "    node* del(node* h, Key k)",
        "    {",
        "      if(h->key > k)",
        "      {",
        "        if(!isred(h->left) && !isred(h->left->left))",
        "          h = moveredleft(h);",
        "        h->left = del(h->left,k);",
        "      }",
        "      else",
        "      {",
        "        if(isred(h->left))",
        "          h = rotateright(h);",
        "        if(h->key == k && (h->right == NULL ))",
        "        {",
        "          delete h;",
        "          return NULL;",
        "        }",
        "        if(!isred(h->right) && !isred(h->right->left))",
        "          h = moveredright(h);",
        "        if(h->key == k)",
        "        {",
        "          node* x = minnode(h->right);",
        "          h->key = x->key;",
        "          h->val = x->val;",
        "          h->right = delmin(h->right);",
        "        }",
        "        else h->right = del(h->right,k);",
        "      }",
        "      return balance(h);",
        "    }",
        "",
        "    node* delmin(node* h)",
        "    {",
        "      if(h->left == NULL) ",
        "      {",
        "        delete h;",
        "        return NULL;",
        "      }",
        "      if(!isred(h->left) && !isred(h->left->left))",
        "        h = moveredleft(h);",
        "      h->left = delmin(h->left);",
        "      return balance(h);",
        "    }",
        "",
        "    node* delmax(node* h)",
        "    {",
        "      if(isred(h->left))",
        "        h = rotateright(h);",
        "      if(h->right == NULL) ",
        "      {",
        "        delete h;",
        "        return NULL;",
        "      }",
        "      if(!isred(h->right) && !isred(h->right->left))",
        "        h = moveredright(h);",
        "      h->right = delmax(h->right);",
        "      return balance(h);",
        "    }",
        "",
        "    node* moveredleft(node* h)",
        "    {",
        "      h = flipcolor(h);",
        "      if(isred(h->right->left))",
        "      {",
        "        h->right = rotateright(h->right);",
        "        h = rotateleft(h);",
        "        h = flipcolor(h);",
        "      }",
        "      return h;",
        "    }",
        "    node* moveredright(node* h)",
        "    {",
        "      h = flipcolor(h);",
        "      if(isred(h->left->left))",
        "      {",
        "        h = rotateright(h);",
        "        h = flipcolor(h);",
        "      }",
        "      return h;",
        "    }",
        "    node* rotateleft(node* h)",
        "    {",
        "      node *x = h->right;",
        "      h->right = x->left;",
        "      x->left = h;",
        "      x->color = x->left->color;",
        "      x->left->color = true;",
        "      sizeupdate(h);",
        "      sizeupdate(x);",
        "      heightupdate(h);",
        "      heightupdate(x);",
        "      return x;",
        "    }",
        "    node* rotateright(node* h)",
        "    {",
        "      node *x = h->left;",
        "      h->left = x->right;",
        "      x->right = h;",
        "      x->color = x->right->color;",
        "      x->right->color = true;",
        "      sizeupdate(h);",
        "      sizeupdate(x);",
        "      heightupdate(h);",
        "      heightupdate(x);",
        "      return x;",
        "    }",
        "    node* flipcolor(node* h)",
        "    {",
        "      h->color = !h->color;",
        "      h->left->color = !h->left->color;",
        "      h->right->color = !h->right->color;",
        "      return h;",
        "    }",
        "    node* balance(node* h)",
        "    {",
        "      if(isred(h->right)) h = rotateleft(h);",
        "      if(isred(h->left) && isred(h->left->left)) h = rotateright(h);",
        "      if(isred(h->left) && isred(h->right)) h = flipcolor(h);",
        "      sizeupdate(h);",
        "      heightupdate(h);",
        "      return h;",
        "    }",
        "",
        "    int rank(node* x,Key k)",
        "    {",
        "      if(x == NULL) return 0;",
        "      if(k < x->key) return rank(x->left,k);",
        "      else if (k > x->key) return 1 + sz(x->left) + rank(x->right,k);",
        "      else return sz(x->left);",
        "    }",
        "",
        "    node* select(node* x,int n)",
        "    {",
        "      int sizeleft = sz(x->left);",
        "      if(sizeleft > n) return select(x->left,n);",
        "      else if(sizeleft == n) return x;",
        "      else return select(x->right,n-sizeleft-1);",
        "    }",
        "",
        "    node* minnode(node* x)",
        "    {",
        "      if(x->left == NULL) return x;",
        "      else return minnode(x->left);",
        "    }",
        "",
        "    node* maxnode(node* x)",
        "    {",
        "      if(x->right == NULL) return x;",
        "      else return maxnode(x->right);",
        "    }",
        "",
        "    node* floor(node* x,Key k)",
        "    {",
        "      if(x == NULL) return NULL;",
        "      if(x->key == k) return x;",
        "      if(x->key > k)  return floor(x->left,k);",
        "      node* t = floor(x->right,k);",
        "      if(t != NULL )  return t;",
        "      else            return x;",
        "    }",
        "",
        "    node* ceil(node* x,Key k)",
        "    {",
        "      if(x == NULL) return NULL;",
        "      if(x->key == k) return x;",
        "      if(x->key < k) return ceil(x->right,k);",
        "      node* t = ceil(x->left,k);",
        "      if(t != NULL) return t;",
        "      else return x;",
        "    }",
        "",
        "    void print2DUtil(node *root, int space)  ",
        "    { ",
        "      #define COUNT 5",
        "      if (root == NULL)  ",
        "        return;  ",
        "      space += COUNT;  ",
        "      print2DUtil(root->right, space);  ",
        "      cout<<endl;  ",
        "      for (int i = COUNT; i < space; i++)  ",
        "        cout<<\" \";  ",
        "      cout<<root->val<<\"\\n\";  ",
        "      print2DUtil(root->left, space);  ",
        "    }  ",
        "  ",
        "    inline int sz(node* h)",
        "    {",
        "      if(h == NULL) return 0;",
        "      return h->size;",
        "    }",
        "",
        "    inline int ht(node* h)",
        "    {",
        "      if(h == NULL ) return 0;",
        "      return h->height;",
        "    }",
        "    ",
        "    void keys(node* x,vector<pair<Key,Value>> &v,Key lo,Key hi)",
        "    {",
        "      if(x == NULL) return;",
        "      if(lo < x->key) keys(x->left,v,lo,hi);",
        "      if(lo <= x->key && hi >= x->key) v.push_back({x->key,x->val});",
        "      if(hi > x->key) keys(x->right,v,lo,hi);",
        "    }",
        "",
        "  public:",
        "",
        "    bool isempty()",
        "    {",
        "      return root == NULL;",
        "    }",
        "",
        "    bool contains(Key key)",
        "    {",
        "      return get(key) != NULL;",
        "    }",
        "",
        "    node* get(Key key)",
        "    {",
        "      return get(root,key);",
        "    }",
        "",
        "    void put( Key key, Value val )",
        "    {",
        "      root = put(root,key,val);",
        "      root->color = false;",
        "    }",
        "",
        "    void del(Key key)",
        "    {",
        "      if(!contains(key)) return;",
        "      if(!isred(root->left) && !isred(root->right)) root->color = true;",
        "      root = del(root,key);",
        "      if(!isempty()) root->color = false;",
        "    }",
        "",
        "    int size()",
        "    {",
        "      return sz(root);",
        "    }",
        "",
        "    int height()",
        "    {",
        "      return ht(root);",
        "    }",
        "",
        "    void visualize()",
        "    {",
        "      print2DUtil(this->root,0);",
        "    }",
        "",
        "    void delmin()",
        "    {",
        "      if(isempty()) return;",
        "      if(!isred(root->left) && !isred(root->right))",
        "        root->color = true;",
        "      root = delmin(root);",
        "      if(!isempty()) root->color = false;",
        "    }",
        "",
        "    void delmax()",
        "    {",
        "      if(isempty()) return;",
        "      if(!isred(root->left) && !isred(root->right))",
        "        root->color = true;",
        "      root = delmax(root);",
        "      if(!isempty()) root->color = false;",
        "    }",
        "",
        "    int rank(Key key) /*RANK OF SMALLEST ELEMENT IS 0. IF ELEMENT NOT PRESENT RETURNS -1*/",
        "    {",
        "      return rank(root,key);",
        "    }",
        "",
        "    node* select(int rank)",
        "    {",
        "      if(rank >= size() || rank < 0) return NULL;",
        "      return select(root,rank);",
        "    }",
        "",
        "    Key minnode()",
        "    {",
        "      if(isempty()) throw underflow_error(\"minnode\");",
        "      return minnode(root)->key;",
        "    }",
        "",
        "    Key maxnode()",
        "    {",
        "      if(root == NULL) throw underflow_error(\"maxnode\");",
        "      return maxnode(root)->key;",
        "    } ",
        "",
        "    node* floor(Key key)",
        "    {",
        "      return floor(root,key);",
        "    }",
        "",
        "    node* ceil(Key key)",
        "    {",
        "      return ceil(root,key);",
        "    }",
        "",
        "    Value operator[] (Key key)",
        "    {",
        "      return get(key)->val;",
        "    }",
        "",
        "    int size(Key lo, Key hi)",
        "    {",
        "      if(hi < lo) return 0;",
        "      if(contains(hi)) return rank(hi) - rank(lo) + 1;",
        "      return rank(hi) - rank(lo);",
        "    }",
        "",
        "    auto keys()",
        "    {",
        "      if(isempty()) return vector<pair<Key,Value>>();",
        "      return keys(minnode(),maxnode());",
        "    }",
        "",
        "    auto keys(Key lo,Key hi)",
        "    {",
        "      vector <pair<Key,Value>> vec;",
        "      keys(root,vec,lo,hi);",
        "      return vec;",
        "    }",
        "",
        "};",
        ""
      ],
      "description": "implements red black tree"
  },
  "BIG INT": {
      "prefix": "big int",
      "body": [
        "/*",
        "  ######################################################################",
        "  #######################   THE   BIG   INT   ##########################",
        "*/",
        " ",
        "const int base = 1000000000;",
        "const int base_digits = 9;",
        " ",
        "struct Int {",
        "   ",
        "    vector<int> a;",
        "    int sign;",
        "   ",
        "    /*<arpa>*/",
        "   ",
        "    int size(){",
        "        if(a.empty()) return 0;",
        "        int ans=(a.size()-1)*base_digits;",
        "        int ca=a.back();",
        "        while(ca)",
        "            ans++,ca/=10;",
        "        return ans;",
        "    }",
        "   ",
        "    Int operator ^(const Int &v){",
        "        Int ans=1,a=*this,b=v;",
        "        while(!b.isZero()){",
        "            if(b%2)",
        "            ans*=a;",
        "            a*=a,b/=2;",
        "        }",
        "        return ans;",
        "    }",
        "   ",
        "    string to_string(){",
        "        stringstream ss;",
        "        ss << *this;",
        "        string s;",
        "        ss >> s;",
        "        return s;",
        "    }",
        "   ",
        "    int sumof(){",
        "        string s = to_string();",
        "        int ans = 0;",
        "        for(auto c : s)  ans += c - '0';",
        "        return ans;",
        "    }",
        "   ",
        "    /*</arpa>*/",
        "   ",
        "    Int() :",
        "    sign(1) {",
        "    }",
        " ",
        "    Int(long long v) {",
        "        *this = v;",
        "    }",
        " ",
        "    Int(const string &s) {",
        "        read(s);",
        "    }",
        " ",
        "    void operator=(const Int &v) {",
        "        sign = v.sign;",
        "        a = v.a;",
        "    }",
        " ",
        "    void operator=(long long v) {",
        "        sign = 1;",
        "        a.clear();",
        "        if (v < 0)",
        "            sign = -1, v = -v;",
        "        for (; v > 0; v = v / base)",
        "            a.push_back(v % base);",
        "    }",
        " ",
        "    Int operator+(const Int &v) const {",
        "        if (sign == v.sign) {",
        "            Int res = v;",
        "            for (int i = 0, carry = 0; i < (int) max(a.size(), v.a.size()) || carry; ++i) {",
        "                if (i == (int) res.a.size())",
        "                    res.a.push_back(0);",
        "                res.a[i] += carry + (i < (int) a.size() ? a[i] : 0);",
        "                carry = res.a[i] >= base;",
        "                if (carry)",
        "                    res.a[i] -= base;",
        "            }",
        "            return res;",
        "        }",
        "        return *this - (-v);",
        "    }",
        " ",
        "    Int operator-(const Int &v) const {",
        "        if (sign == v.sign) {",
        "            if (abs() >= v.abs()) {",
        "                Int res = *this;",
        "                for (int i = 0, carry = 0; i < (int) v.a.size() || carry; ++i) {",
        "                    res.a[i] -= carry + (i < (int) v.a.size() ? v.a[i] : 0);",
        "                    carry = res.a[i] < 0;",
        "                    if (carry)",
        "                    res.a[i] += base;",
        "                }",
        "                res.trim();",
        "                return res;",
        "            }",
        "            return -(v - *this);",
        "        }",
        "        return *this + (-v);",
        "    }",
        " ",
        "    void operator*=(int v) {",
        "        if (v < 0)",
        "            sign = -sign, v = -v;",
        "        for (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {",
        "            if (i == (int) a.size())",
        "                a.push_back(0);",
        "            long long cur = a[i] * (long long) v + carry;",
        "            carry = (int) (cur / base);",
        "            a[i] = (int) (cur % base);",
        "            //asm(\"divl %%ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));",
        "        }",
        "        trim();",
        "    }",
        " ",
        "    Int operator*(int v) const {",
        "        Int res = *this;",
        "        res *= v;",
        "        return res;",
        "    }",
        " ",
        "    void operator*=(long long v) {",
        "        if (v < 0)",
        "            sign = -sign, v = -v;",
        "        for (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {",
        "            if (i == (int) a.size())",
        "                a.push_back(0);",
        "            long long cur = a[i] * (long long) v + carry;",
        "            carry = (int) (cur / base);",
        "            a[i] = (int) (cur % base);",
        "            //asm(\"divl %%ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));",
        "        }",
        "        trim();",
        "    }",
        " ",
        "    Int operator*(long long v) const {",
        "        Int res = *this;",
        "        res *= v;",
        "        return res;",
        "    }",
        " ",
        "    friend pair<Int, Int> divmod(const Int &a1, const Int &b1) {",
        "        int norm = base / (b1.a.back() + 1);",
        "        Int a = a1.abs() * norm;",
        "        Int b = b1.abs() * norm;",
        "        Int q, r;",
        "        q.a.resize(a.a.size());",
        " ",
        "        for (int i = a.a.size() - 1; i >= 0; i--) {",
        "            r *= base;",
        "            r += a.a[i];",
        "            int s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];",
        "            int s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];",
        "            int d = ((long long) base * s1 + s2) / b.a.back();",
        "            r -= b * d;",
        "            while (r < 0)",
        "                r += b, --d;",
        "            q.a[i] = d;",
        "        }",
        " ",
        "        q.sign = a1.sign * b1.sign;",
        "        r.sign = a1.sign;",
        "        q.trim();",
        "        r.trim();",
        "        return make_pair(q, r / norm);",
        "    }",
        " ",
        "    Int operator/(const Int &v) const {",
        "        return divmod(*this, v).first;",
        "    }",
        " ",
        "    Int operator%(const Int &v) const {",
        "        return divmod(*this, v).second;",
        "    }",
        " ",
        "    void operator/=(int v) {",
        "        if (v < 0)",
        "            sign = -sign, v = -v;",
        "        for (int i = (int) a.size() - 1, rem = 0; i >= 0; --i) {",
        "            long long cur = a[i] + rem * (long long) base;",
        "            a[i] = (int) (cur / v);",
        "            rem = (int) (cur % v);",
        "        }",
        "        trim();",
        "    }",
        " ",
        "    Int operator/(int v) const {",
        "        Int res = *this;",
        "        res /= v;",
        "        return res;",
        "    }",
        " ",
        "    int operator%(int v) const {",
        "        if (v < 0)",
        "            v = -v;",
        "        int m = 0;",
        "        for (int i = a.size() - 1; i >= 0; --i)",
        "            m = (a[i] + m * (long long) base) % v;",
        "        return m * sign;",
        "    }",
        " ",
        "    void operator+=(const Int &v) {",
        "        *this = *this + v;",
        "    }",
        "   ",
        "    void operator-=(const Int &v) {",
        "        *this = *this - v;",
        "    }",
        "   ",
        "    void operator*=(const Int &v) {",
        "        *this = *this * v;",
        "    }",
        "   ",
        "    void operator/=(const Int &v) {",
        "        *this = *this / v;",
        "    }",
        "   ",
        "    Int operator ++(){",
        "        *this += 1;",
        "        return *this;",
        "    }",
        "   ",
        "    Int operator ++(int){",
        "        Int temp = *this;",
        "        *this += 1;",
        "        return temp;",
        "    }",
        "   ",
        "    Int operator --(){",
        "        *this -= 1;",
        "        return *this;",
        "    }",
        "   ",
        "    Int operator --(int){",
        "        Int temp = *this;",
        "        *this -= 1;",
        "        return temp;",
        "    }",
        " ",
        "    bool operator<(const Int &v) const {",
        "        if (sign != v.sign)",
        "            return sign < v.sign;",
        "        if (a.size() != v.a.size())",
        "           return a.size() * sign < v.a.size() * v.sign;",
        "        for (int i = a.size() - 1; i >= 0; i--)",
        "            if (a[i] != v.a[i])",
        "                return a[i] * sign < v.a[i] * sign;",
        "        return false;",
        "    }",
        " ",
        "    bool operator>(const Int &v) const {",
        "        return v < *this;",
        "    }",
        "   ",
        "    bool operator<=(const Int &v) const {",
        "        return !(v < *this);",
        "    }",
        "   ",
        "    bool operator>=(const Int &v) const {",
        "        return !(*this < v);",
        "    }",
        "   ",
        "    bool operator==(const Int &v) const {",
        "        return !(*this < v) && !(v < *this);",
        "    }",
        "   ",
        "    bool operator!=(const Int &v) const {",
        "        return *this < v || v < *this;",
        "    }",
        " ",
        "    void trim() {",
        "        while (!a.empty() && !a.back())",
        "            a.pop_back();",
        "        if (a.empty())",
        "            sign = 1;",
        "    }",
        " ",
        "    bool isZero() const {",
        "        return a.empty() || (a.size() == 1 && !a[0]);",
        "    }",
        " ",
        "    Int operator-() const {",
        "        Int res = *this;",
        "        res.sign = -sign;",
        "        return res;",
        "    }",
        " ",
        "    Int abs() const {",
        "        Int res = *this;",
        "        res.sign *= res.sign;",
        "        return res;",
        "    }",
        " ",
        "    long long longValue() const {",
        "        long long res = 0;",
        "        for (int i = a.size() - 1; i >= 0; i--)",
        "            res = res * base + a[i];",
        "        return res * sign;",
        "    }",
        " ",
        "    friend Int gcd(const Int &a, const Int &b) {",
        "        return b.isZero() ? a : gcd(b, a % b);",
        "    }",
        "   ",
        "    friend Int lcm(const Int &a, const Int &b) {",
        "        return a / gcd(a, b) * b;",
        "    }",
        " ",
        "    void read(const string &s) {",
        "        sign = 1;",
        "        a.clear();",
        "        int pos = 0;",
        "        while (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {",
        "            if (s[pos] == '-')",
        "                sign = -sign;",
        "            ++pos;",
        "        }",
        "       ",
        "        for (int i = s.size() - 1; i >= pos; i -= base_digits) {",
        "            int x = 0;",
        "            for (int j = max(pos, i - base_digits + 1); j <= i; j++)",
        "                x = x * 10 + s[j] - '0';",
        "            a.push_back(x);",
        "        }",
        "        trim();",
        "    }",
        " ",
        "    friend istream& operator>>(istream &stream, Int &v) {",
        "        string s;",
        "        stream >> s;",
        "        v.read(s);",
        "        return stream;",
        "    }",
        " ",
        "    friend ostream& operator<<(ostream &stream, const Int &v) {",
        "        if (v.sign == -1)",
        "           stream << '-';",
        "        stream << (v.a.empty() ? 0 : v.a.back());",
        "        for (int i = (int) v.a.size() - 2; i >= 0; --i)",
        "            stream << setw(base_digits) << setfill('0') << v.a[i];",
        "        return stream;",
        "    }",
        " ",
        "    static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {",
        "        vector<long long> p(max(old_digits, new_digits) + 1);",
        "        p[0] = 1;",
        "        for (int i = 1; i < (int) p.size(); i++)",
        "            p[i] = p[i - 1] * 10;",
        "        vector<int> res;",
        "        long long cur = 0;",
        "        int cur_digits = 0;",
        "        for (int i = 0; i < (int) a.size(); i++) {",
        "            cur += a[i] * p[cur_digits];",
        "            cur_digits += old_digits;",
        "            while (cur_digits >= new_digits) {",
        "                res.push_back(int(cur % p[new_digits]));",
        "                cur /= p[new_digits];",
        "                cur_digits -= new_digits;",
        "            }",
        "        }",
        "        res.push_back((int) cur);",
        "        while (!res.empty() && !res.back())",
        "            res.pop_back();",
        "        return res;",
        "    }",
        " ",
        "    typedef vector<long long> vll;",
        " ",
        "    static vll karatsubaMultiply(const vll &a, const vll &b) {",
        "        int n = a.size();",
        "        vll res(n + n);",
        "        if (n <= 32) {",
        "            for (int i = 0; i < n; i++)",
        "                for (int j = 0; j < n; j++)",
        "                    res[i + j] += a[i] * b[j];",
        "            return res;",
        "        }",
        " ",
        "        int k = n >> 1;",
        "        vll a1(a.begin(), a.begin() + k);",
        "        vll a2(a.begin() + k, a.end());",
        "        vll b1(b.begin(), b.begin() + k);",
        "        vll b2(b.begin() + k, b.end());",
        " ",
        "        vll a1b1 = karatsubaMultiply(a1, b1);",
        "        vll a2b2 = karatsubaMultiply(a2, b2);",
        " ",
        "        for (int i = 0; i < k; i++)",
        "            a2[i] += a1[i];",
        "        for (int i = 0; i < k; i++)",
        "            b2[i] += b1[i];",
        " ",
        "        vll r = karatsubaMultiply(a2, b2);",
        "       ",
        "        for (int i = 0; i < (int) a1b1.size(); i++)",
        "            r[i] -= a1b1[i];",
        "        for (int i = 0; i < (int) a2b2.size(); i++)",
        "            r[i] -= a2b2[i];",
        " ",
        "        for (int i = 0; i < (int) r.size(); i++)",
        "            res[i + k] += r[i];",
        "        for (int i = 0; i < (int) a1b1.size(); i++)",
        "            res[i] += a1b1[i];",
        "        for (int i = 0; i < (int) a2b2.size(); i++)",
        "            res[i + n] += a2b2[i];",
        "        return res;",
        "    }",
        " ",
        "    Int operator*(const Int &v) const {",
        "        vector<int> a6 = convert_base(this->a, base_digits, 6);",
        "        vector<int> b6 = convert_base(v.a, base_digits, 6);",
        "       ",
        "        vll a(a6.begin(), a6.end());",
        "        vll b(b6.begin(), b6.end());",
        "       ",
        "        while (a.size() < b.size())",
        "            a.push_back(0);",
        "        while (b.size() < a.size())",
        "            b.push_back(0);",
        "        while (a.size() & (a.size() - 1))",
        "            a.push_back(0), b.push_back(0);",
        "           ",
        "        vll c = karatsubaMultiply(a, b);",
        "        Int res;",
        "        res.sign = sign * v.sign;",
        "        for (int i = 0, carry = 0; i < (int) c.size(); i++) {",
        "            long long cur = c[i] + carry;",
        "            res.a.push_back((int) (cur % 1000000));",
        "            carry = (int) (cur / 1000000);",
        "        }",
        "        res.a = convert_base(res.a, 6, base_digits);",
        "        res.trim();",
        "        return res;",
        "    }",
        "   ",
        "    //Added part.",
        "   ",
        "    friend Int max(const Int &a,const Int &b){",
        "        if(a<b){",
        "            return a;",
        "        }",
        "        return b;",
        "    }",
        "   ",
        "    friend Int max(const Int &a,const int32_t &B){",
        "        Int b = B;",
        "        return max(a,b);",
        "    }",
        "   ",
        "    friend Int max(const Int &a,const int64_t &B){",
        "        Int b = B;",
        "        return max(a,b);",
        "    }",
        "   ",
        "    friend Int min(const Int &a,const Int &b){",
        "        if(a>b){",
        "            return b;",
        "        }",
        "        return a;",
        "    }",
        "   ",
        "    friend Int min(const Int &a,const int32_t &B){",
        "        Int b = B;",
        "        return min(a,b);",
        "    }",
        "   ",
        "    friend Int min(const Int &a,const int64_t &B){",
        "        Int b = B;",
        "        return min(a,b);",
        "    }",
        "   ",
        "    friend Int pow(const Int &a,const Int &b){",
        "        Int _c = 1;",
        "        Int _b = b;",
        "        Int _a = a;",
        "        while(_b != 0){",
        "            if(_b%2){",
        "                _c *= _a;",
        "            }",
        "            _a *= _a;",
        "            _b /= 2;",
        "        }",
        "        return _c;",
        "    }",
        "   ",
        "    friend Int pow(const Int &a,const int32_t &B){",
        "        Int b = B;",
        "        return pow(a,b);",
        "    }",
        "   ",
        "    friend Int pow(const Int &a,const int64_t &B){",
        "        Int b = B;",
        "        return pow(a,b);",
        "    }",
        "   ",
        "    friend Int sqrt(Int a) {",
        "        Int x0 = a, x1 = (a+1)/2;",
        "        while (x1 < x0) {",
        "            x0 = x1;",
        "            x1 = (x1+a/x1)/2;",
        "        }",
        "        return x0;",
        "    }",
        "};",
        "/*",
        "  #######################   THE   BIG   INT   ##########################",
        "  ######################################################################",
        "*/"
      ],
      "description": "BIG INT"
  },


}